<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dashboard</title>
<style>
  :root{
    --green1:#12b886;
    --green2:#0ca678;
    --tab-h:56px;
    --anim:0.75s;
  }

  /* Loading bar */
  #loadingBarWrap{position:fixed;top:0;left:0;right:0;height:4px;z-index:9999;overflow:hidden;pointer-events:none}
  #loadingBar{position:absolute;top:0;left:-40%;height:100%;width:40%;
    background:linear-gradient(90deg,#9ff6d0,#26b893,#9ff6d0);animation:none}
  @keyframes indeterminate{0%{left:-40%;width:40%}50%{left:20%;width:60%}100%{left:100%;width:40%}}

 /* === DASHBOARD SHEET (Notes-style) ======================================== */
:root{
  --dash-handle-h: 44px;
  /* Full screen height using dynamic viewport units */
  --dash-open-h: 100dvh;
}


/* Dark backdrop for Dashboard */
#dashOverlay{
  position: fixed; inset: 0;
  background: rgba(0,0,0,.35);
  display: none;
  z-index: 10040; /* just below notes (10050) so Notes can still sit above if both open */
}

#dashSheet{
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 10055;   /* above #dashOverlay */
  /* Keep rounded top corners visible when minimized */
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  box-shadow: 0 -8px 24px rgba(0,0,0,.25);
  background: #fff;

  /* Fill the entire screen height */
  height: var(--dash-open-h);
  max-height: var(--dash-open-h);
  width: 100%;

  display: flex;
  flex-direction: column;

  /* Closed state sits with only the handle visible; open = slide to full height */
  transform: translateY(calc(100% - var(--dash-handle-h)));
  transition: transform .25s ease;
  will-change: transform;
  contain: layout paint;
}


/* Green handle / tap target */
#dashHandle{
  height: var(--dash-handle-h);
  background: linear-gradient(135deg, var(--green1), var(--green2));
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  display: flex; align-items: center; justify-content: center;
  color: #fff;
  font-weight: 800; letter-spacing: .3px;
  cursor: pointer; user-select: none;
  position: relative; z-index: 1;
}

/* Scrollable body area */
#dashBody{
  flex: 1 1 auto;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 12px 14px 16px;
  min-height: 0;
}

/* Open/Closed states */
#dashSheet.dashboard-open  { transform: translateY(0); }
#dashSheet.dashboard-closed{ transform: translateY(calc(100% - var(--dash-handle-h))); }

/* Optional: cards reused inside Dashboard */
#dashBody .card{border:1px solid #e9ecef;border-radius:14px;padding:10px;margin-bottom:12px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
#dashBody .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

/* Reuse your textarea & buttons from earlier */
#dashBody #noteInput{
  width:100%;min-height:150px;resize:vertical;
  font-size:28px;line-height:1.35;padding:12px;border-radius:12px;border:1px solid #ced4da;
}

#dashBody .btn{border:0;border-radius:10px;padding:6px 10px;font-size:11px;font-weight:800;cursor:pointer}
#dashBody .btn:active{transform:translateY(1px)}
#dashBody #addBtn{background:linear-gradient(135deg,var(--green1),var(--green2));color:#fff}



#dashBody #recentList .item{display:flex;gap:10px;align-items:flex-start;padding:8px 6px;border-bottom:1px dashed #e5e7eb}
#dashBody #recentList .note{flex:1;white-space:pre-wrap;font-size:16px}
#dashBody #recentList .meta{font-size:11px;color:#495057}
#dashBody #recentList .assigned{font-weight:800;color:#0ca678}
#dashBody input[type="text"].small{padding:6px 8px;border:1px solid #ced4da;border-radius:8px;font-size:12px}



/* === Mobile fit & 50% viewport textarea ================================ */
@media (max-width: 640px) {
  /* Ensure the sheet and handle span the full width */
  #dashSheet { width: 100vw; max-width: 100vw; }
  #dashHandle { width: 100%; }

  /* Make the textarea consume half the screen height */
  #dashBody #noteInput{
    width: 100%;
    /* Use small-viewport units to avoid iOS URL bar issues */
    height: 50svh;
    min-height: 50svh;
    max-height: 50svh;
  }

  /* Keep action row from overflowing; stack buttons full-width */
  #dashBody .row{
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
 #dashBody .btn,
#dashBody #addBtn{
  width: 100%;
  margin-left: 0;
  margin-right: 0;
}


  /* Avoid horizontal scroll due to padding */
  #dashBody{
    padding-left: 12px;
    padding-right: 12px;
    box-sizing: border-box;
  }
}

/* === Mobile textarea hard height (force) — 2x (50 -> 100) = full screen === */
@media (max-width: 640px) {
  /* Highest practical specificity + !important */
  #dashBody textarea#noteInput {
    height: 100dvh !important;   /* doubled from 50dvh */
    min-height: 100dvh !important;
    max-height: 100dvh !important;
    width: 100% !important;
    box-sizing: border-box;
    resize: none;
  }
}


/* === 2x SCALE OVERRIDES (fonts + textarea) ============================== */
/* Global bump for rem/em-based text */
html { font-size: 200%; }

/* Make the green handle label bigger */
#dashHandle { font-size: 2rem; }

/* Double the textarea font + desktop min-height (150px -> 300px) */
#dashBody #noteInput {
  font-size: 75px;     /* was 28px */
  min-height: 550px;   /* was 150px */
}

/* Double common px-based text */
#dashBody .btn                { font-size: 44px; }  /* was 11px */
#dashBody #recentList .note   { font-size: 64px; }  /* was 16px */
#dashBody #recentList .meta   { font-size: 44px; }  /* was 11px */
#dashBody input[type="text"].small { font-size: 48px; }  /* was 12px */

/* === Toast notification (bottom-center) ================================ */
#toast{
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translateX(-50%) translateY(8px);
  background: rgba(33, 37, 41, .96);
  color: #fff;
  padding: 12px 16px;
  border-radius: 10px;
  font-weight: 700;
  font-size: 16px;
  letter-spacing: .2px;
  box-shadow: 0 10px 24px rgba(0,0,0,.25);
  z-index: 10080; /* above overlays/sheets */
  opacity: 0;
  pointer-events: none;
  transition: opacity .18s ease, transform .18s ease;
}
#toast.show{
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
@media (max-width:640px){
  #toast{ 
    width: calc(100vw - 24px);
    text-align: center;
    font-size: 18px;
  }
}
/* === TOP-OF-SCREEN LOADING BAR (BLUE) =================================== */
#loadingBarWrap{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  z-index: 200000;        /* keep above overlays/sheets/toasts */
  overflow: hidden;
  pointer-events: none;
}

#loadingBar{
  position: absolute;
  top: 0;
  left: -40%;
  height: 100%;
  width: 40%;
  /* Blue gradient (was green) */
  background: linear-gradient(90deg, #9ec5fe, #1d4ed8, #9ec5fe);
  animation: none;        /* set by startLoading() */
}

@keyframes indeterminate{
  0%   { left: -40%; width: 40%; }
  50%  { left: 20%;  width: 60%; }
  100% { left: 100%; width: 40%; }
}



</style>
</head>



<body>
  <!-- your dashboard stays under this -->
<!-- Keep these elements once in your HTML -->


  <!-- Loading bar -->
  
  <div id="loadingBarWrap"><div id="loadingBar"></div></div>

  <!-- Overlay that slides; tab moves with it -->
  <!-- === DASHBOARD (Notes-style bottom sheet) ============================= -->
<div id="dashOverlay" aria-hidden="true"></div>
<div id="dashSheet" class="dashboard-closed" aria-hidden="true">
  <div id="dashHandle" role="button" aria-controls="dashSheet" aria-expanded="false">
     CHANGE VIEW
  </div>

  <div id="dashBody" role="region" aria-label="Dashboard content">
    <div class="card">
      <textarea id="noteInput"></textarea>
<div class="row" style="margin-top:8px;">
  <button id="addBtn" class="btn">ADD</button>
  <span id="addStatus" class="meta" style="margin-left:4px"></span>
</div>

    </div>

    <div class="card" id="recentCard">
      <div id="recentList"></div>
    </div>
  </div>
</div>
<!-- ===================================================================== -->


  <!-- Autocomplete (same list as main page, minus category) -->
  <datalist id="clientNamesList"></datalist>

<script>
  /* Loading bar */
  const bar = document.getElementById('loadingBar');
  function startLoading(){ bar.style.animation='indeterminate var(--anim) ease-in-out infinite'; }
  function stopLoading(){ bar.style.animation='none'; bar.style.left='-40%'; }
  // Toast helper: shows a message for ~2 seconds
function showToast(msg){
  const t = document.getElementById('toast');
  if(!t) return;
  t.textContent = msg || '';
  t.classList.add('show');
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=> t.classList.remove('show'), 2000);
}

/* Expand/Collapse: tab rides with panel — NOTES-style toggle */
/* === DASHBOARD: Notes-style open/close =================================== */
(function(){
  const sheet   = document.getElementById('dashSheet');
  const handle  = document.getElementById('dashHandle');
  const overlay = document.getElementById('dashOverlay');

  if (!sheet || !handle) return;

  function setState(isOpen){
    sheet.classList.toggle('dashboard-open',   isOpen);
    sheet.classList.toggle('dashboard-closed', !isOpen);

    sheet.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    handle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

    if (overlay){
      overlay.style.display = isOpen ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    }
    try { sessionStorage.setItem('v1.dashboardOpen', String(isOpen)); } catch(_){}
  }
  function isOpen(){ return sheet.classList.contains('dashboard-open'); }

  // expose if needed elsewhere
  window.openDashboard   = () => setState(true);
  window.closeDashboard  = () => setState(false);
  window.toggleDashboard = () => setState(!isOpen());

  // wiring
  handle.addEventListener('click', () => window.toggleDashboard());
  if (overlay) overlay.addEventListener('click', () => window.closeDashboard());

  // Esc to close
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && isOpen()) window.closeDashboard();
  });

// initial state — default OPEN (and still restore if previously saved)
let startOpen = true;
try {
  const saved = sessionStorage.getItem('v1.dashboardOpen');
  if (saved === 'true') startOpen = true;
  if (saved === 'false') startOpen = false;
} catch(_){}
setState(startOpen);

})();


  /* Autocomplete */
  function loadClientNames(){
    startLoading();
    google.script.run.withSuccessHandler(names=>{
      const dl = document.getElementById('clientNamesList');
      dl.innerHTML = '';
      (names||[]).forEach(n=>{
        const opt=document.createElement('option'); opt.value=n; dl.appendChild(opt);
      });
      stopLoading();
    }).getClientNamesSimple();
  }

  /* Add / Submit (Submit intentionally small; wiring same add unless you want different) */
  const noteInput = document.getElementById('noteInput');
  const addStatus = document.getElementById('addStatus');


const addBtn = document.getElementById('addBtn');


function addNote(){
  const txt = (noteInput.value || '').trim();
  if (!txt) { addStatus.textContent = ''; return; }

  startLoading();
  addStatus.textContent = '';
  addBtn.disabled = true;

  google.script.run
    .withSuccessHandler(_ => {
      noteInput.value = '';
      // Refresh list, then stop loader (inside loadRecent), then re-enable + toast
      loadRecent(() => {
        addBtn.disabled = false;
        showToast('Note added successfully');
      });
    })
    .withFailureHandler(err => {
      console.log(err);
      stopLoading();
      addBtn.disabled = false;
      showToast('Error adding note');
    })
    .inboxAddNote(txt);
}


addBtn.addEventListener('click', addNote);

    /* Recent (5) with assign */
  const recentList = document.getElementById('recentList');

  function renderRecent(payload){
    recentList.innerHTML='';
    const items=(payload&&payload.recent)?payload.recent:[];
    if(!items.length){ return; }

    items.forEach(it=>{
      const row=document.createElement('div'); 
      row.className='item';

      // LEFT: note text
      const note=document.createElement('div'); 
      note.className='note'; 
      note.textContent=it.note;

      // RIGHT: timestamp + assign input (auto-assigns on selection)
      const side=document.createElement('div'); 
      side.style.minWidth='280px';

      // Timestamp only (NO green assigned label)
      const meta=document.createElement('div'); 
      meta.className='meta';
      meta.textContent = it.timestamp ? it.timestamp : '';

      // Wider input: 360px (twice the previous 180px)
      const inp=document.createElement('input'); 
      inp.type='text'; 
      inp.className='small'; 
      inp.setAttribute('list','clientNamesList'); 
      inp.style.width='360px';

      // Keep selection visible in the input (no extra green label elsewhere)
      inp.value = it.assigned || '';
      inp.placeholder = it.assigned ? 'Change assignment…' : 'Assign…';

      // Auto-assign handler
      function commitAssign(){
        const name = (inp.value||'').trim();
        if(!name) return;
        startLoading();
        google.script.run
.withSuccessHandler(_=>{
  stopLoading();
  showToast('Client note has been updated successfully');
})

          .withFailureHandler(err=>{
            alert(err && err.message ? err.message : String(err));
            stopLoading();
          })
          .inboxAssignToClient(it.row, name);
      }

      // Assign immediately when a value is chosen or Enter is pressed
      inp.addEventListener('change', commitAssign);
      inp.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ 
          e.preventDefault(); 
          commitAssign(); 
        }
      });

      // Layout row (no Assign button, no green label)
      const r=document.createElement('div'); 
      r.className='row'; 
      r.appendChild(inp);

      side.appendChild(meta);
      side.appendChild(document.createElement('div')).style.height='6px';
      side.appendChild(r);

      row.appendChild(note); 
      row.appendChild(side);
      recentList.appendChild(row);
    });
  }

function loadRecent(done){
  startLoading();
  google.script.run
    .withSuccessHandler(p=>{
      renderRecent(p);
      stopLoading();                 // ⬅️ stop only after items render
      if (typeof done === 'function') done();
    })
    .withFailureHandler(e=>{
      console.log(e);
      stopLoading();
      if (typeof done === 'function') done(e);
    })
    .inboxGetRecent(25);
}



  window.addEventListener('load', ()=>{ loadClientNames(); loadRecent(); });

// Mobile textarea height fallback (enforce 50vh on load/resize)
(function(){
  function enforceMobileNoteHeight(){
    const ta = document.getElementById('noteInput');
    if (!ta) return;
    const isMobile = window.matchMedia('(max-width: 640px)').matches;
    if (isMobile) {
      // Try dvh/svh first; fall back to vh if needed
      ta.style.height     = '50dvh';
      ta.style.minHeight  = '50dvh';
      ta.style.maxHeight  = '50dvh';
      // If the browser doesn't understand dvh, set vh as a fallback
      // (some engines keep the last valid value)
      ta.style.height     = '50vh';
      ta.style.minHeight  = '50vh';
      ta.style.maxHeight  = '50vh';
    } else {
      ta.style.height = ta.style.minHeight = ta.style.maxHeight = '';
    }
  }
  window.addEventListener('load', enforceMobileNoteHeight);
  window.addEventListener('resize', enforceMobileNoteHeight);
  window.addEventListener('orientationchange', enforceMobileNoteHeight);
})();


 (function(){
    const sheet   = document.getElementById('notesSheet');
    const handle  = document.getElementById('notesHandle');
    const overlay = document.getElementById('notesOverlay');
    const listEl  = document.getElementById('notesList');
    const dl      = document.getElementById('clientNamesDatalist');

    const addBtn  = document.getElementById('btnAddInbox');
    const newNote = document.getElementById('inboxNewNote');

    // ✅ PUT THESE LINES RIGHT HERE:
    if (overlay && overlay.parentNode !== document.body) {
      document.body.appendChild(overlay);   // moves it (doesn't clone)
    }
    if (sheet && sheet.parentNode !== document.body) {
      document.body.appendChild(sheet);     // moves it under <body>
    }

    // Toggle by tapping the GREEN part (and overlay)
(function(){
  const sheet   = document.getElementById('notesSheet');
  const handle  = document.getElementById('notesHandle');
  const overlay = document.getElementById('notesOverlay');

  if (!sheet || !handle) return; // safety

  function setState(isOpen){
    sheet.classList.toggle('notes-open',   isOpen);
    sheet.classList.toggle('notes-closed', !isOpen);
    sheet.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    handle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

    if (overlay){
      overlay.style.display = isOpen ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    }

    // remember state so re-clicking the tab behaves
    try { sessionStorage.setItem('v1.notesOpen', String(isOpen)); } catch(_){}
  }

  function isOpen(){
    return sheet.classList.contains('notes-open');
  }

  // expose (if other code calls them)
  window.openSheet  = function(){ setState(true);  };
  window.closeSheet = function(){ setState(false); };
  window.toggleSheet= function(){ setState(!isOpen()); };

  // wire clicks
  handle.addEventListener('click', toggleSheet);
  if (overlay) overlay.addEventListener('click', closeSheet);

  // don’t close when interacting inside the form
  sheet.addEventListener('click', function(e){
    if (e.target.closest('form, textarea, input, select, button, [contenteditable]')) {
      e.stopPropagation();
    }
  }, true);

  // Esc to close
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape' && isOpen()) closeSheet();
  });

  // Initial state (restore last)
  let startOpen = false;
  try { startOpen = sessionStorage.getItem('v1.notesOpen') === 'true'; } catch(_){}
  setState(startOpen);
})();


    // listeners, loaders, etc...
  })();

</script>
<div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>

</body>
</html>












<!DOCTYPE html>
<html>
<head>
    <base target="_top">
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

   <style>
  :root {
    --background-color: #E6F0FF; /* Default background color */
    --text-color: #000000; /* Default text color - black */
    --secondary-color: #f0f0f0; /* Secondary color for hover state - light gray */
    --button-color: #add8e6; /* Light blue color for buttons */
      --submit-button-color: #BFA2DB; /* Define a slightly purple color */
          --darker-blue: #007bff; /* Example darker blue */

  }

  body {
      font-family: Arial, sans-serif; /* Consistent font throughout */
    font-size: 1.5em;
      color: var(--text-color);

  }
/* ... other CSS styles ... */

.note-textarea {
    background-color: white; /* Set background color to white */
  margin: 0 auto; /* Auto margins for horizontal centering */
}

/* ... other CSS styles ... */

input, button, select {
  border-radius: 4px;
  padding: 10px;
  font-size: 1em;
}

#categoryChangeSection, #addToCalendarBtn, #addAppointmentBtn {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#futureWorkSection {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  font-size: 14px; /* Adjust the size as needed */
}


#newFollowUp {
  background-color: white; /* Set to light blue as defined in your root variables */
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#pastWorkSection {
  background-color: #D3D3D3; /* Set to light grey */
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    font-size: 16px; /* Adjust the size as needed */

}


#submitTaskBtn {
    color: #000000; /* Black font color */
}


  label, {
    font-weight: bold;
    letter-spacing: 1px;
    text-transform: uppercase;
    font-size: 1em;
    border-radius: 4px;
    padding: 10px;
  margin: 0 auto; /* Auto margins for horizontal centering */

  }
 
 #clientSelect {
  display: none;
}




  body * {
    font-size: 1.5em;
  }

  #newFollowUp, button {
    font-size: 1.5em;
  }

  #categorySelect {
    font-size: 1.5em;
    width: 100%; /* Sets the width to 100% of the parent container */
    box-sizing: border-box; /* Ensures padding and borders are included in the width */
}

.client-mention {
  color: #0066cc;
  text-decoration: underline;
  cursor: pointer;

  /* keep size/shape identical to surrounding text */
  font-size: inherit;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  text-transform: none;
}



#autocompleteSuggestions {
    border: 1px solid #ccc;
    border-top: none;
    position: absolute;
    z-index: 1000;
    background-color: white;
    width: 100%;
    top: 100%;
    left: 0;
    max-height: none; /* Set a maximum height */
    overflow-y: auto;  /* Enable vertical scrolling */
}



  #topClientsDisplay ol {
    list-style-type: decimal;
  }

  #autocompleteSuggestions div {
    padding: 10px;
    cursor: pointer;
  }

  #autocompleteSuggestions div:hover {
    background-color: #f0f0f0;
  }

  .smaller-size {
    transform: scale(0.4);
  }

  button {
    background-color: var(--button-color);
    color: black;
    border: none;
    border-radius: 4px;
    padding: 10px 20px;
    text-transform: uppercase;
    font-weight: bold;
    letter-spacing: 1px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    cursor: pointer;
     display: block; /* Make button a block element */
  margin: 0 auto; /* Auto margins for horizontal centering */
  }

  button:hover, button:focus {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        filter: brightness(85%); /* Darken button on hover/focus */

  }

button:active {
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    transform: translateY(1px);
        filter: brightness(75%); /* Further darken button when active/pressed */

}


 #addAppointmentBtn {
    background-color: red; /* Light red color */
  }


  #newClientForm button {
  background-color: var(--submit-button-color); /* Use the purple color variable */
  }

.button-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px; /* Adjust the space between buttons as needed */
}




  .secondary-button {
    background-color: var(--background-color);
    color: var(--text-color);

  }

  .primary-button {
    background-color: var(--accent-color);
  }
  #newNoteSection button {
  background-color: var(--submit-button-color); /* Use the purple color variable */
}

/* New CSS class for styling the task display */
.task-display {
    font-size: 0.8em; /* Smaller text */
    width: 100%; /* Adjust width as needed */
    padding: 15px; /* More padding for larger box */
    border: 1px solid #ccc; /* Optional border */
    margin-bottom: 10px; /* Spacing between boxes */
}
.update-team-task-btn {
  background-color: var(--submit-button-color); /* Purple background */
  color: var(--text-color); /* Black text color */
  /* Rest of the styling similar to the 'Submit New Note' button */
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  text-transform: uppercase;
  font-weight: bold;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  cursor: pointer;
    font-size: 225%;

}

.update-team-task-btn:hover, .update-team-task-btn:focus {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  filter: brightness(85%);
}

.update-team-task-btn:active {
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  transform: translateY(1px);
  filter: brightness(75%);
}
 .container {
    display: flex; /* Use flexbox for layout */
    justify-content: space-around; /* Space out items evenly */
    align-items: start; /* Align items to the start of the container */
  }

  .notes-section, .follow-ups-section {
    flex-basis: 30%; /* Set a base width for both sections */
    padding: 20px; /* Add some padding */
    margin: 10px; /* Add some margin */
  }

  .divider {
    height: 100%; /* Full height divider */
    width: 1px; /* Thin line as a divider */
    background-color: #000; /* Black color for the divider */
    margin: 0 20px; /* Margin to space out from sections */
  }

#topClientsHr {
    border-top: 2px solid black; /* Adjust the color as needed */
}

#teamTasks3Display textarea {
    width: 100%; /* Make the textbox take full width */
    box-sizing: border-box; /* Include padding and border in the width */
}

#autocompleteSuggestions .autocomplete-active {
  background-color: blue; /* Change to blue */
  color: white;           /* Make text readable on blue background */
}


/* Centering container for client name input */
.client-name-container {
    text-align: center; /* Center align the content */
    margin: 0 auto; /* Center the container */
    width: 100%; /* Set width to full container width */
}

/* Styling for the client name input */
#clientAutocomplete {
    display: inline-block; /* Make the input an inline-block element */
    margin-top: 10px; /* Add some top margin for spacing */
}
#pastWorkSection {
  background-color: #D3D3D3; /* Existing styles */
  /* ... other styles ... */
  text-align: center; /* Center-align content within the section */
}


#newNoteSection {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  text-align: center; /* Center-align content within the section */
}





#categoryChangeSection {
  background-color: var(--background-color);
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  text-align: center; /* Center-align content within the section */
    margin: 0 auto; /* Auto margins for horizontal centering */

}

.category-label {
  display: block; /* Make label a block element */
  margin-bottom: 10px; /* Space between label and select */
}

.category-select {
  display: block;
  margin: 0;
  width: auto;
    margin: 0 auto; /* Auto margins for horizontal centering */

 
}

#appointmentInputSection {
  text-align: center; /* Center-align content within the section */
  padding: 20px;
  margin-bottom: 20px;
  background-color: var(--background-color);
  border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.appointment-label {
  display: block; /* Make label a block element */
  margin: 10px auto; /* Center label and add space above and below */
}

.appointment-input {
  display: block; /* Make input a block element */
  margin: 0 auto; /* Center the input field */
  width: 50%; /* Adjust width as needed */
  padding: 10px; /* Padding for better appearance */
  border-radius: 4px; /* Rounded corners */
  border: 1px solid #ccc; /* Border styling */
}

#appointmentInputSection button {
  display: block; /* Make button a block element */
  margin: 20px auto; /* Center the button and add space above and below */
  /* Additional button styling as needed */
}

#loadingBarContainer {
    width: 100%;
    background-color: #f3f3f3;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1001; /* Increase z-index to stay above other elements */
}


#loadingBar {
    height: 5px;
    width: 0; /* Start with an empty bar */
    background-color: #4caf50;
    transition: width 10s ease; /* Transition for width property */
}

#piechart {
  width: 900px; /* Adjust as necessary */
  height: 500px; /* Adjust as necessary */
  margin: 0 auto; /* Center the div */
}

#heatmap, #futureHeatmap {
  width: 900px; /* Existing width */
  height: 700px; /* Increased height */
  margin: 0 auto; /* Center the div */
}


#heatmap text {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}

#futureHeatmap text {
  font-size: 12px; /* Ensure font size is consistent with the first heatmap */
  transform: none; /* Ensure no scaling is applied */
}

/* If using classes for text labels, you could also do something like this: */
.chart-label {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}

/* CSS rule for adjusting the font size of the scatter plot label */
#scatter_chart_div text {
  font-size: 12px; /* Adjust the font size as needed */
  transform: none; /* Ensure no scaling is applied */
}



.label-box {
    padding: 5px;
    margin: 5px;
    border: 1px solid #ddd;
    display: inline-block; /* or 'block' if you want each label on a new line */
    background-color: #f0f0f0;
}

/* Add this CSS rule to initially hide the label section */
#labelsSection {
  display: none;
}

#labelsDropdown {
    width: 100vw; /* Sets the width to span the entire viewport width */
    box-sizing: border-box; /* Includes padding and border in the width */
    /* Additional styling as needed */
}


.client-container {
    position: fixed;
    top: 0; /* Set to the height of the loading bar */
    left: 0;
    width: 100%;
    background-color: var(--background-color);
    z-index: 1000; /* Lower than loading bar */
    padding: 10px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}


body {
    margin-top: 0; /* Adjust the value to match the height of the fixed header */
}



.client-name-container, .client-select-container {
  flex: 1; /* This will allow each child to take up equal space */
  margin-right: 10px; /* Space between the elements, adjust as needed */
}

/* Make sure the input and select elements are 100% width of their containers */
input#clientAutocomplete, select#clientSelect {
  width: 100%;
  box-sizing: border-box; /* Include padding and borders in the element's total width */
}

.labels-container {
  display: flex;
  width: 100%;
}

#labelsDisplay {
  flex-basis: 85%; /* Assign 90% of the parent container's width to labels display */
    font-size: 65%; /* This will set the font size to half of the inherited size */

}

#labelsAdditionSection {
  flex-basis: 15%; /* Assign 10% of the parent container's width to the dropdown */
  display: none;
}

#labelsDropdown {
  width: 100%; /* Ensure the dropdown fills its container */
  box-sizing: border-box; /* Include padding and borders in the element's total width */
    font-size: 65%; /* This will set the font size to 65% of the inherited size */

}



#toggleNotesButton {
  background-color: #FFDAB9; /* Peach Puff color, a light orange shade */
  margin-top: 5px;
  font-size: 65%;
  }

.inline-button {
  display: inline-flex; /* Make button an inline-flex element */
  margin: 0; /* Remove auto margins */
  /* Any other specific styles you want these buttons to have */
}


/* When you want to display the labelsAdditionSection, you can change its style to 'display: block' or 'display: flex' as needed with JavaScript */

#topClientsBtn, #calendarTasksBtn, #todayButton {
    background-color: var(--darker-blue); /* Use the darker blue color */
}

.highlighted {
    background-color: yellow;
}

/* ===== NAME LINKIFY + HOVER BUBBLE ===== */
.client-mention {
  color: #0066cc;
  text-decoration: underline;
  cursor: pointer;
}

#nameHoverBubble {
  position: absolute;
  z-index: 10002;
  display: none;
  max-width: 380px;
  max-height: 260px;
  overflow-y: auto;
  background: #ffffff;
  border: 1px solid #999;
  border-radius: 8px;
  padding: 8px 10px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
  font-size: 0.9em;
}

#nameHoverBubble .bubble-title {
  font-weight: bold;
  margin-bottom: 6px;
}

#nameHoverBubble .bubble-item {
  padding: 6px 8px;
  border-radius: 6px;
  margin: 4px 0;
  cursor: pointer;
}

#nameHoverBubble .bubble-item:hover {
  background: #f0f6ff;
}


#columnBDropdown, #columnDDropdown {
  width: 100%;
  /* No font-size line here—now it inherits the same larger 1.5em size as JB/RICKY */
  margin-top: 0px;
  margin-bottom: 0px;
}


/* Hover style for items not active */
#autocompleteSuggestions div:hover:not(.autocomplete-active) {
    background-color: #f0f0f0;
}

/* Style for the active suggestion */
#autocompleteSuggestions div.autocomplete-active {
    background-color: blue;
    color: white;
}

#autocompleteSuggestions {
    position: absolute;
    top: calc(100% + 5px); /* Position it just below the input field */
    left: 0;
    width: 100%;
    z-index: 1001; /* Ensure it's above other elements */
    max-height: 200px; /* Set a maximum height */
    overflow-y: auto; /* Enable vertical scrolling if needed */
    background-color: white;
    border: 1px solid #ccc;
    border-top: none;
}


#pastWorkSection, #futureWorkSection {
  flex: 1;
}

#pastWorkSection, #futureWorkSection {
  box-sizing: border-box;
}

.past-work-label, .future-work-label {
    display: block;
    margin-bottom: 10px;
    font-size: 40px; /* Adjust font size as needed */
    text-align: center; /* Center align labels if desired */


}


.past-work-textarea, .future-work-textarea {
    display: block;
    margin: 0 auto;
    width: 100%;
    height: 150px; /* Adjust height as needed */
        box-sizing: border-box;
            min-width: 0;  /* Allow the textarea to shrink */


}


.update-team-task-btn, .secondary-button {
  margin: 10px auto;
}

#notesDisplay * {
  box-sizing: border-box;
}

#pastWorkSection, #futureWorkSection {
  font-size: 16px;
}

.client-button {
    font-weight: normal;
}

/* Top Clients list buttons only */
#topClientsDisplay .inline-button,
#topClientsDisplay .client-button,
#topClientsDisplay button {
  font-size: 0.7em;  /* tweak as needed */
}


/* Allow parent containers to grow */
#notesDisplay {
    overflow: visible;
}

#notesDisplay div {
    flex-grow: 1;
}

/* Optional: Add styling for the note lines */
.note-line {
    margin-bottom: 5px; /* Adjust as needed */
}

.future-work-actions {
    display: flex;
    flex-wrap: wrap; /* Allow items to wrap to the next line */
    justify-content: flex-end;
    padding-top: 10px;
    align-items: center;
}

#dateInputContainer {
    margin-right: 10px;
    flex: 1 1 auto; /* Allow the container to shrink properly */
    min-width: 0;   /* Allow the container to shrink below its content size */
    
}


#futureWorkDate {
    width: 100%; /* Make sure the input takes full width of its container */
    box-sizing: border-box; /* Include padding and border in the width */
        min-width: 0;  /* Allow the input to shrink below its content size */

}

.future-work-actions button {
    flex: 1 1 auto; /* Allow the button to shrink and grow */
    width: auto; /* Let the button adjust its width automatically */
}

@media (max-width: 600px) {
    /* When the screen width is less than 600px, stack the elements vertically */
    .future-work-actions {
        flex-direction: column;
        align-items: stretch;
    }



    .future-work-actions button {
        width: 100%; /* Button takes full width */
    }
}


#userSelection {
    width: 100%;
    box-sizing: border-box;
    min-width: 0; /* Allow the select dropdown to shrink */
}

#futureWorkSection {
    min-width: 0; /* Allow the entire section to shrink */
}


/* The Modal (background) */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 9999; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black with opacity */
}

/* Modal Content/Box */
.modal-content {
    background-color: #fefefe;
    margin: 5% auto; /* Centered */
    padding: 20px;
    border: 1px solid #888;
    width: 90%; /* Adjust as needed */
    max-width: 800px;
}

/* Close Button */
.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
}



#addNewClientBtn {
    display: inline-block; /* Changes display to inline-block */
    margin: 10px 0;        /* Adds vertical margin, removes horizontal centering */
}

.modal-content input,
.modal-content select {
    width: 100%;          /* Input fields occupy full width */
    box-sizing: border-box; /* Includes padding and border in the element's total width */
    font-size: 1.5em;     /* Adjust font size as needed */
}


.title-button-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

#topClientsTitle {
    font-size: 1.25em;
    font-weight: bold;
    text-align: left; /* Align text to the left */
    margin: 0;        /* Remove default margins */
}

#topClientsByCategoryBtn,
#addNewClientBtn {
    /* Ensure the button has consistent styling */
    font-size: 1em;
    padding: 10px 20px;
    /* Additional styles as needed */
}

#scrollBottomBtn {
    /* Match #addNewClientBtn's font/size so the button text is the same size */
    display: inline-block;
    margin: 10px 0;
    font-size: 1em; /* If your Add New Client is 1em, use 1em here as well */
}



#toggleNotesButton, #columnDDropdown {
  padding-top: 5px; /* Reduce padding-top */
  padding-bottom: 5px; /* Reduce padding-bottom */
}

.star-button {
    background-color: lightblue;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
}

.star-button:hover {
    color: gold;
}

.title-button-container {
    display: flex;
    flex-direction: column; /* Stack elements vertically */
    align-items: center;
    margin-bottom: 20px;
}

#topClientsHeader {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px; /* Space between header and "Add New Client" button */
}

#topClientsTitle {
    margin-right: 10px;
    font-size: 1.25em;
    font-weight: bold;
    text-align: center;
}

#topClientsByCategoryBtn {
    /* Adjust styles if needed */
}

#addNewClientBtn {
    /* Center the button */
    margin: 0 auto;
}
.modal-content {
    background-color: #fefefe;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 90%;
    max-width: 800px;
}

#categoriesModalContent {
    font-size: 14px; /* Adjust the font size as needed */
    text-align: center; /* Center the text if desired */
}

#categoriesModalContent p {
    margin: 5px 0; /* Reduce margin between paragraphs */
}


/* Container styling */
.title-button-container {
    display: flex;
    flex-direction: column;
    margin-bottom: 20px;
}

/* Row styling */
.row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%; /* Ensure rows take full width */
}

/* Title text styling */
.title-text {
    font-size: 1.25em;
    font-weight: bold;
    text-align: left;
}

/* Buttons align to the right */
.row button {
    margin-left: auto; /* Push buttons to the right */
}

.title-button-container {
    /* Ensures the container spans the full screen width */
    width: 100vw;
    position: relative;
}

/* Each row now only left-aligns its text. We remove justify-content: space-between so text stays at left */
.row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    position: relative; /* Needed for absolute positioning of buttons */
    width: 100%;
}

/* Absolutely position the buttons to the right edge of the screen */
.row button {
    position: absolute;
    right: 0;
    margin: 0; /* Remove any auto-margins that might shift the buttons */
}

/* SNIPPET #1: STAR ANIMATION CSS - REPLACEMENT */
.star-animation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  /* Just a slightly dark overlay + big centered star emoji */
  background: rgba(10, 10, 0, 0.75);
  z-index: 999999; /* Sit on top of everything */
  pointer-events: none; /* Don’t let this block clicks */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 300px; 
}
.star-animation::before {
  content: "⭐";
}


/* SNIPPET TO ADD A GAP BETWEEN THE EMAIL SUMMARY BUTTON ROW 
   AND THE ADD NEW CLIENT BUTTON ROW */
#dateCategoryRow {
  margin-bottom: 20px; /* Adjust as needed to create more or less space */
}

/* SNIPPET #2 (REPLACED): make filter dropdown look like a button and hide arrow */
/* SNIPPET #2 (RESTORED): native select with arrow */
#topClientsFilterDropdown {
  /* Restore the platform's native dropdown look + arrow */
  appearance: auto !important;
  -webkit-appearance: menulist !important; /* Safari/Chrome */
  -moz-appearance: menulist !important;    /* Firefox */

  /* Undo the button-y overrides */
  background: revert;
  background-image: revert;
  border: revert;
  border-radius: revert;
  padding: revert;
  line-height: revert;
  height: revert;
  cursor: default;

  /* Keep only what you still want */
  font-size: 1em;    /* optional: keep your sizing */
  width: auto;       /* optional */
  margin-left: 5px;  /* keep the small gap from nearby controls */
}



.chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  border-radius: 9999px;
  font-weight: 600;           /* to resemble your button text weight */
  line-height: 1.2;
  margin-left: 8px;           /* small gap from the text it follows */
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.08);
  user-select: none;
}

.chip .chip-initials { text-transform: uppercase; }
.chip .chip-sep { opacity: 0.7; }
.chip .chip-date { letter-spacing: 0.2px; }

/* Colors: on top of yellow highlight */
.chip.JB { background: #1E90FF; color: #fff; }   /* blue */
.chip.RB { background: #28A745; color: #fff; }   /* green */
.chip.QC { background: #FF8C00; color: #fff; }   /* orange */
.chip.TEAM { background: #800080; color: #fff; }   /* orange */

.chip.EMPTY { background: #f0f0f0; color: #333; }/* placeholder neutral */

/* === CHIP SIZE OVERRIDE (2/3 scale) — PASTE AFTER EXISTING .chip RULES === */
.chip {
  /* shrink overall text to 2/3 of the surrounding size */
  font-size: 0.6667em;

  /* shrink paddings and gaps proportionally */
  padding: 1.333px 5.333px;   /* was 2px 8px */
  gap: 4px;                   /* was 6px */

  /* keep pill shape, borders, weights, etc. */
  border-radius: 9999px;
  font-weight: 600;
  line-height: 1.2;

  /* optional: slightly smaller left margin to match scale */
  margin-left: 5.333px;       /* was 8px */
}

/* inner bits scale automatically with font-size.
   leaving these for clarity in case you customize later */
.chip .chip-initials { text-transform: uppercase; }
.chip .chip-sep { opacity: 0.7; }
.chip .chip-date { letter-spacing: 0.2px; }

/* Keep your color classes as-is; no changes needed:
   .chip.JB, .chip.RB, .chip.QC, .chip.EMPTY */

.chip .chip-sep {
  color: #000;   /* force black */
  opacity: 1;    /* make fully opaque */
}


/* Wrapper anchors the absolute button & suggestions */
.client-input-wrap {
  position: relative;
  width: 100%;        /* fill available width */
  /* no max-width, no auto-centering */
}

/* Keep input’s *outer* size unchanged; just add internal space for the button */
#clientAutocomplete {
  width: 100%;
  box-sizing: border-box;
  padding-right: 130px; /* room for the button; tweak if your button is wider/narrower */
}

/* Put the existing NEW CLIENT button on the right edge of the bar */
#addNewClientBtn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;             /* override global button { margin: 0 auto } */
  display: inline-block;  /* override global button { display: block } */
  z-index: 2;            /* sit above the input */
}

#notesDisplay strong {
  font-size: inherit; /* Prevents bold from shrinking or enlarging */
  font-weight: bold;  /* Keep bold effect */
}

#topClientsDisplay strong {
  font-size: inherit;  /* keep same size as surrounding note text */
  font-weight: bold;   /* still be bold */
}

/* ——— Ricky’s Suggestion block: green wrapper, white textarea ——— */
.toplist-suggestion{
  background-color:#90EE90;   /* light green */
  padding:10px;
  border:1px solid #ccc;
  border-radius:4px;
  margin-top:8px;
}
.toplist-suggestion .note-textarea{
  background:white;           /* keep input white */
}

/* Make SUGGESTIONS button match SCROLL DOWN sizing */
#suggestionsToggleBtn{
  display:inline-block;
  font-size: 1em;             /* same as #scrollBottomBtn */
}

/* Toolbar row (JB/RB/QC + filter arrow + SUGGESTIONS) */
.top-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Make the Suggestions button match your toolbar sizing */
#suggestionsToggleBtn {
  display: inline-block;
  padding: 6px 10px;
  font-size: 1em; /* same visual scale as your other controls */
}

/* Ricky’s Suggestion: full-width green block, textarea stays white */
.toplist-suggestion {
  background-color: #90EE90; /* light green */
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;

  /* FULL-WIDTH rules */
  width: 100%;
  box-sizing: border-box;
  margin-left: 0;
  margin-right: 0;
}
.toplist-suggestion .note-textarea {
  background: white;     /* input stays white */
  width: 100%;           /* full width inside the green block */
  box-sizing: border-box;
}

#editNotesButton { font-size: 0.66em; }

  .recent-bar { display:flex; flex-wrap:wrap; gap:.5rem; padding:.5rem 0; }
  .recent-pill {
    display:flex; align-items:center; gap:.4rem;
    border:1px solid #ddd; border-radius:9999px; padding:.35rem .7rem; cursor:pointer;
    font-size:.9rem; background:#fff;
  }
  .rc-name { font-weight:600; }
  .rc-cat { font-size:.75rem; padding:.05rem .4rem; border:1px solid #eee; border-radius:8px; }
  .rc-chip { font-size:.7rem; opacity:.8; }
  .rc-dot { width:.5rem; height:.5rem; border-radius:50%; background:#4caf50; }
  .rc-muted { opacity:.35; } /* when Column L empty */
/* OVERRIDE: keep recent chips full strength */
.recent-bar .rc-muted { opacity: 1 !important; }

/* Make the blue box visually contain chips + input cleanly */
.client-input-wrap {
  position: relative;           /* already present, keep it */
  background: #ffffff;          /* white interior so chips/input stand out */
  border: 2px solid #1E90FF;    /* blue outline */
  border-radius: 10px;
  padding: 10px 140px 12px 12px; /* top/right/bottom/left; right = room for NEW CLIENT button */
  box-shadow: 0 2px 5px rgba(0,0,0,0.06);
}

/* Chips bar when placed inside the autocomplete wrapper */
.recent-bar.inside-autocomplete {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 0 0 8px 0;           /* space below chips before the input */
  padding: 0;
}

/* Keep the input border simple since the blue box provides the outline */
#clientAutocomplete {
  border: 1px solid #ccc;
  border-radius: 6px;
  padding-right: 130px;        /* already present; keep for the button on the right */
  width: 100%;
  box-sizing: border-box;
}

/* Ensure the suggestion list still anchors just under the input and stays within the blue box */
/* Keep suggestions visually inside the blue box and not covering content below */
#autocompleteSuggestions {
  position: absolute;
  z-index: 1001;      /* above the input, below the loading bar (1001 is fine) */
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px); /* just below the input inside the blue box */
  max-height: 200px;
  overflow-y: auto;
  background-color: white;
  border: 1px solid #ccc;
  border-top: none;
}


/* Keep the NEW CLIENT button floating over the right edge of the blue box */
#addNewClientBtn {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;
  z-index: 2;
}

/* Chip visuals (already present)—no change needed; this just ensures consistent scale in the tighter space */
.chip { font-size: 0.6667em; }

/* === INLINE NEW CLIENT BUTTON INSIDE CHIPS BAR === */

/* Make the blue box padding uniform now that the button isn't absolutely positioned */
.client-input-wrap {
  padding: 10px 12px 12px 12px; /* override previous padding with big right space */
}

/* Chips bar already flexes; just keep it tidy */
.recent-bar.inside-autocomplete {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 0 0 8px 0;
  padding: 0;
}

/* NEW CLIENT button styled to sit among the chips, with two stacked lines */
#addNewClientBtn,
.recent-add-btn {
  display: inline-flex;
  flex-direction: column;      /* stack NEW / CLIENT */
  align-items: center;
  justify-content: center;
  gap: 2px;
  font-weight: 700;
  line-height: 1.1;
  padding: .35rem .7rem;
  border-radius: 9999px;
  border: 1px solid #ddd;
  background: var(--submit-button-color);  /* your purple */
  color: var(--text-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,.12);
  /* Sit at the end of the chips row */
  order: 99;
}

/* Remove any absolute positioning from earlier */
#addNewClientBtn {
  position: static !important;
  right: auto !important;
  top: auto !important;
  transform: none !important;
  margin: 0;                   /* inline with chips */
}

/* Input no longer needs extra right padding for an absolute button */
#clientAutocomplete {
  padding-right: 12px !important;
}

/* Keep suggestions neatly inside the blue box */
#autocompleteSuggestions {
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px);
}

/* === Chips (left) + NEW CLIENT (right) inline row inside blue box === */
.recent-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 0 0 8px 0; /* space below row before the input */
}

/* Let chips use all the leftover width; wrap nicely */
.recent-row .recent-bar.inside-autocomplete {
  flex: 1 1 auto;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  min-width: 0; /* allow wrapping in narrow screens */
}

/* Make the blue box padding uniform now that the button isn't absolute */
.client-input-wrap {
  padding: 10px 12px 12px 12px !important; /* override any earlier larger right padding */
  border: 2px solid #1E90FF;
  border-radius: 10px;
  background: #fff;
}

/* NEW CLIENT button: real button, stacked text, sits on the right */
#addNewClientBtn.recent-add-btn {
  display: inline-flex;
  flex-direction: column;     /* "NEW" on top of "CLIENT" */
  align-items: center;
  justify-content: center;
  gap: 2px;
  font-weight: 700;
  line-height: 1.1;
  padding: .4rem .8rem;
  border-radius: 9999px;
  border: 1px solid #ddd;
  background: var(--submit-button-color); /* your purple */
  color: var(--text-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,.12);
  white-space: nowrap;        /* keep the two-line label neat */
}

/* Strip any old absolute positioning */
#addNewClientBtn {
  position: static !important;
  right: auto !important;
  top: auto !important;
  transform: none !important;
  margin: 0 !important;
}

/* Input no longer needs huge right padding (button is not on top of it) */
#clientAutocomplete {
  padding-right: 12px !important;
}

/* Keep suggestions neatly inside the blue box */
#autocompleteSuggestions {
  left: 12px;
  right: 12px;
  width: auto;
  top: calc(100% + 6px);
}

/* Hide status dots in recent chips */
.rc-dot { display: none !important; }
/* === RECENT CLIENTS: show ONLY the name === */
#recentClientsBar .rc-cat,
#recentClientsBar .rc-chip,
#recentClientsBar .rc-dot {
  display: none !important;
}

/* keep the pill compact now that only the name shows */
#recentClientsBar .recent-pill {
  gap: 0.25rem;
  padding: .35rem .6rem;
}

#recentClientsBar .rc-name {
  font-weight: 600;
}

/* === NEW CLIENT button: standard look, right side of the blue box === */
#addNewClientBtn {
  position: absolute;       /* anchor to the blue box */
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  margin: 0;                /* no auto-centering */
  display: inline-block;    /* standard button look */
  white-space: nowrap;      /* keep "NEW CLIENT" on one line */
}

/* Ensure the input leaves room for the absolutely-positioned button */
#clientAutocomplete {
  padding-right: 130px !important;
}

/* Make sure the blue wrapper keeps the absolute button inside it */
.client-input-wrap {
  position: relative !important;
}


/* === NEW CLIENT button (two-line), aligned right of recent chips === */

/* Make the row a proper flex container; chips take space, button sits at the end */
.recent-row#recentRow {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Let chips wrap and consume available width */
.recent-row#recentRow .recent-bar.inside-autocomplete {
  flex: 1 1 auto;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  min-width: 0;
  margin-right: 0px;
}

/* Two-line NEW CLIENT pill on the right; standard button styling + stacked text */
#addNewClientBtn {
  margin-left: auto;            /* push button to the right */
  display: inline-flex;
  flex-direction: column;       /* NEW above CLIENT */
  align-items: center;
  justify-content: center;
  white-space: normal;          /* allow the line break */
  line-height: 1.1;             /* tighten the two lines slightly */
  padding: 10px 20px;           /* match your standard button padding */
  border-radius: 4px;           /* match your global button radius */
  background: var(--submit-button-color); /* same purple you use for submit-style buttons */
  color: var(--text-color);
  font-weight: bold;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  cursor: pointer;
}

/* Keep spans block-level so the text stacks cleanly with no weird gaps */
#addNewClientBtn span { display: block; }

/* Hover/active states consistent with other buttons */
#addNewClientBtn:hover, #addNewClientBtn:focus {
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  filter: brightness(85%);
}
#addNewClientBtn:active {
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  transform: translateY(1px);
  filter: brightness(75%);
}

/* Ensure the input no longer reserves right-side padding (button is in-row now) */
#clientAutocomplete {
  padding-right: 12px !important;
}

/* Make sure the blue wrapper is the containing context */
.client-input-wrap {
  position: relative !important;
    padding: 10px 12px !important;

}

/* Ensure consistent, not-huge sizing for the button */
#addNewClientBtn,
#addNewClientBtn.recent-add-btn {
  font-size: 1rem;     /* prevent inherited upsizing */
  line-height: 1.1;    /* tight lines so it looks clean */
  display: inline-flex;
  flex-direction: column;  /* NEW over CLIENT */
  align-items: center;
  gap: 2px;                /* single, small gap between lines */
}

/* Stack spans cleanly (no extra breaks) */
#addNewClientBtn span {
  display: block;
  margin: 0;              /* no extra space */
  padding: 0;
}
/* FIX: Nudge the NEW CLIENT button slightly left */
#addNewClientBtn {
  margin-right: 30px !important;
}


</style>


</head>
<body onload="loadAllHeatmaps()">
    <!-- Loading Bar -->

  <div id="loadingBarContainer" style="display: none;">
    <div id="loadingBar"></div>
</div>

<!-- Hover bubble for name suggestions -->
<div id="nameHoverBubble" role="listbox" aria-label="Related clients"></div>

<div class="client-container">
  <div class="client-input-wrap">
    <!-- RECENT CLIENTS: inside the blue box, above the input -->
<!-- RECENT CLIENTS: inside the blue box, chips on the left; NEW CLIENT on the right -->
<div class="recent-row" id="recentRow">
  <div id="recentClientsBar" class="recent-bar inside-autocomplete"></div>

  <!-- Single, two-line button on the right -->
  <button id="addNewClientBtn" type="button" class="recent-add-btn" onclick="displayAddNewClientModal()">
    <span>NEW</span><span>CLIENT</span>
  </button>
</div>


</div>

    <input type="text" id="clientAutocomplete"
           placeholder="Type Client Name"
           oninput="autocompleteClient()">

  </div>

  <select id="clientSelect" onchange="showClientNotes()" style="display: none;">
    <option value="" disabled selected>Select a Client</option>
  </select>
</div>






<div class="labels-container">
  <div id="labelsDisplay">
    <!-- Labels will be displayed here -->
  </div>
  <div id="labelsAdditionSection">
       <select id="labelsDropdown" onchange="addLabelToClient(this.value)" style="width: 100%;">
      <option value="" disabled selected>Add a Label</option>
      <!-- Options will be dynamically populated here -->
      <option value="NEW LABEL">NEW LABEL</option>
    </select>
   
   
   

  </div>
</div>







<!-- The rest of your HTML remains unchanged -->


<!-- Labels display section -->


<!-- Notes display, shown after client selection -->
<div id="notesDisplay">
    <!-- Notes will be displayed here -->
</div>

<!-- Rest of your code... -->



              <!-- Notes will be displayed here -->

  <div id="workSectionsContainer" style="display: flex; flex-direction: row; justify-content: space-between; align-items: stretch;">

    
    <!-- Past Work submission -->
<div id="pastWorkSection" style="flex: 1 1 100%; padding-right: 0; display: none; flex-direction: column; justify-content: flex-end; width: 100%; max-width: 100%;">
        <textarea id="newPastWork" class="past-work-textarea"></textarea>
        <br>
        <button class="update-team-task-btn" onclick="submitPastWork()">Submit Note</button>
        <br>
<div style="background-color: #90EE90; padding: 10px;">
  <label for="loadedInProgressArea" style="font-weight: bold;">💡:</label>
  <br>
  <textarea id="loadedInProgressArea"
            style="width: 100%; min-height: 60px; background-color: white;"
            onblur="onInProgressLoadedBlur(this.value)">
  </textarea>
</div>
<br>


    </div>
<!-- Future Work submission (deprecated/removed) -->
<!-- intentionally left blank -->


</div>



</div>




<!-- Area to display clients based on selected category -->
<div id="categoryClientsDisplay">
    <!-- Clients will be displayed here -->
</div>

<!-- Category update selection, initially hidden until a client is selected -->
<div id="categoryChangeSection" style="display:none;">
  <select id="categorySelect" class="category-select">
    <option value="">Select a category...</option>
  </select>
</div>




<br>
<!-- Button to show appointment scheduling inputs -->
<button id="addAppointmentBtn" class="secondary-button" onclick="showAppointmentInput()" style="display:none;">Add APPOINTMENT to Calendar for This Client</button>

<!-- Appointment scheduling inputs, initially hidden -->
<div id="appointmentInputSection" style="display:none;">
    <label for="appointmentDate" class="appointment-label">Appointment Date:</label>
    <input type="date" id="appointmentDate" class="appointment-input">

    <label for="appointmentTime" class="appointment-label">Appointment Time:</label>
    <input type="time" id="appointmentTime" class="appointment-input">

    <button onclick="submitAppointmentToCalendar()">Submit APPOINTMENT to Calendar</button>
</div>



<!-- Add the HIDE CLIENT NOTES button here -->
<button id="hideClientNotesBtn" class="secondary-button" onclick="hideClientNotes()" style="display:none;">HIDE CLIENT NOTES</button>


<hr style="border: 4px solid black;">
<!-- Removed the 'button-container' div -->
<!-- Container for title and buttons -->
<div id="titleButtonContainer" class="title-button-container">
    <!-- First Row: Date and Category Button -->
    <div class="row" id="dateCategoryRow">
        <div id="dateTitle" class="title-text"></div>
        <!-- SNIPPET A: REPLACEMENT BUTTON -->
<button id="scrollBottomBtn" class="secondary-button" onclick="scrollToBottomInOneSecond()">SCROLL DOWN</button>

    </div>

    <!-- Under #scrollBottomBtn -->


    <!-- Second Row: Top Clients Title and Add New Client Button -->
    <div class="row" id="topClientsAddNewRow">
  <div id="topClientsTitle" class="title-text"></div>

  <!-- FILTER DROPDOWN (unchanged) -->
  <select id="topClientsFilterDropdown">
  <option value="JB">JB</option>
  <option value="RB">RB</option>
  <option value="QC">QC</option>
    <option value="TEAM">TEAM</option>
    <option value="BRIEFCASE">💼</option>
    <option value="STAR">⭐</option>
    <option value="GRADCAP">🎓</option>
    <option value="PHONE">📞</option>
  </select>

  <!-- NEW: SUGGESTIONS button inline with the dropdown -->
  <button id="suggestionsToggleBtn" type="button" class="secondary-button" onclick="toggleSuggestions()">
    SUGGESTIONS
  </button>

</div>

</div>



<!-- Modal for displaying categories -->
<div id="categoriesModal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close" onclick="closeCategoriesModal()">&times;</span>
        <h2>Category: #</h2>
        <div id="categoriesModalContent">
            <!-- Content will be dynamically added here -->
        </div>
    </div>
</div>


<div id="topClientsDisplay"></div> <!-- Client display area -->

<!-- Modal for adding new client -->
<div id="addClientModal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close" onclick="closeAddClientModal()">&times;</span>
        <div id="addClientModalContent">
            <!-- Content will be dynamically added -->
        </div>
    </div>
</div>

<!-- Modal for NEW CATEGORY -->
<div id="newCategoryModal" class="modal" style="display:none;">
  <div class="modal-content">
    <span class="close" onclick="closeNewCategoryModal()">&times;</span>
    <h2>Add New Category</h2>
    <p>Type a new category name (this will be saved to the selected client and appear in the list next load):</p>
    <input id="newCategoryInput" type="text" placeholder="e.g., Referral, Prospect A, Family" />
    <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end;">
      <button class="secondary-button" onclick="closeNewCategoryModal()">Cancel</button>
      <button onclick="confirmNewCategory()">Save</button>
    </div>
  </div>
</div>



<hr>
<!-- ==================================== -->
<!-- BEGIN SNIPPET B: ADVANCED TOGGLE     -->
<!-- ==================================== -->
<hr style="border: 3px solid black;"> 

<div id="advancedContainer" style="display: none;">
    <button onclick="displayFilteredClients('all')">All</button>

    <div id="quadrantSelection" style="display: grid; grid-template-columns: repeat(2, auto); gap: 20px; margin-bottom: 20px;">
      <button id="immediateBtn" onclick="selectButton('immediateBtn', '#FF0000', 'strictPast')">IMMEDIATE</button>
      <button id="pendingBtn" onclick="selectButton('pendingBtn', '#FFFF00', 'strictUpcoming')">PENDING</button>
      <button id="deferredBtn" onclick="selectButton('deferredBtn', '#FFA500', 'flexiblePast')">DEFERRED</button>
      <button id="adjustableBtn" onclick="selectButton('adjustableBtn', '#0000FF', 'flexibleUpcoming')">ADJUSTABLE</button>
    </div>

    <button onclick="displayFilteredClients('others')">Others</button>

    <hr>
    <button id="todayButton" class="secondary-button" onclick="showTodaysTasks()">APPOINTMENTS</button>
    <div id="todaysTasksDisplay" style="display:none;"></div>

    <hr>
    <div id="timeSensitiveTasksDisplay">
        <!-- Time-sensitive tasks will be displayed here -->
    </div>

    <hr>
    <hr>
    <div id="tasksDisplay"></div> <!-- Make sure this element is present -->

    <hr>
    <button id="birthdaysBtn" class="secondary-button" onclick="displayBirthdays()">Birthdays</button>
    <!-- Birthdays Display Section -->
    <div id="birthdaysDisplay">
        <!-- Birthday information will be populated here -->
    </div>

    <hr>
    <button id="loadNotesButton" class="secondary-button">TODAY</button>
    <div id="notesDisplayArea">

      <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
        <button onclick="filterClients('Sun')" style="width: 110px; height: 60px; font-size: small;">Sun</button>
        <button onclick="filterClients('Mon')" style="width: 110px; height: 60px; font-size: small;">Mon</button>
        <button onclick="filterClients('Tues')" style="width: 110px; height: 60px; font-size: small;">Tues</button>
        <button onclick="filterClients('Wed')" style="width: 110px; height: 60px; font-size: small;">Wed</button>
        <button onclick="filterClients('Thurs')" style="width: 110px; height: 60px; font-size: small;">Thurs</button>
        <button onclick="filterClients('Fri')" style="width: 110px; height: 60px; font-size: small;">Fri</button>
        <button onclick="filterClients('Sat')" style="width: 110px; height: 60px; font-size: small;">Sat</button>
      </div>

      <div id="clientDisplay"></div>

      <hr> 
      <button id="graphsBtn" onclick="toggleGraphs()">GRAPHS</button>
      <br>
      <div id="graphsContainer">

        <div id="tableContainer"></div>
        <div id="piechart" class="centered-chart"></div>
        <div id="heatmap" class="centered-chart"></div>
        <div id="futureHeatmap" class="centered-chart"></div>
        <div id="scatter_chart_div" class="centered-chart"></div>

      </div> <!-- /graphsContainer -->
    </div> <!-- /notesDisplayArea -->

</div> <!-- /advancedContainer -->
<!-- ==================================== -->
<!--  END SNIPPET B                      -->
<!-- ==================================== -->



<!-- COMMENT OUT ENDS HERE -->

<!-- Add this div to your HTML -->

<!-- Rest of your HTML content ... -->

<!-- SNIPPET #2: UPDATE BUTTON + TASKS DISPLAY -->


<div id="updateTasksContainer" style="border:3px solid black; padding:10px; margin:10px;">
  <h2>TASKS FROM SPREADSHEET</h2>
  <!-- We will dynamically populate the tasks here -->
  <div id="tasksList"></div>
</div>
<!-- END SNIPPET #2 -->


<script>

// Global: whether suggestion textareas in the Top Clients list are visible
window.__suggestionsVisible = false;

function toggleSuggestions() {
  window.__suggestionsVisible = !window.__suggestionsVisible;
  applySuggestionsVisibility();
}


// ===== REQUEST TOKEN to prevent stale paints =====
let __topClientsRenderToken = 0;

// Wrap your getTopClients + render in a token-protected function
function fetchAndRenderTopClientsFromDropdown() {
  const dd = document.getElementById('topClientsFilterDropdown');
  const wantedFilter = dd && dd.value ? dd.value.trim() : 'JB';

  const token = ++__topClientsRenderToken;

  google.script.run
    .withSuccessHandler(function (clients) {
      // If a newer request started since we launched, ignore this result
      if (token !== __topClientsRenderToken) return;

      // Normalize the value again right before render
      const dd2 = document.getElementById('topClientsFilterDropdown');
      const currentFilter = dd2 && dd2.value ? dd2.value.trim() : wantedFilter;

      // Use your existing renderer consistently
      if (typeof showTopClients === 'function') {
        showTopClients(clients, currentFilter);
      } else if (typeof showTopClientsOnLoad === 'function') {
        showTopClientsOnLoad(clients, currentFilter);
      }

      // Keep your suggestion visibility wiring
      if (typeof wireToplistSuggestionTextareas === 'function') wireToplistSuggestionTextareas();
      if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
    })
    .withFailureHandler(function (err) {
      console.error('fetchAndRenderTopClientsFromDropdown failed:', err);
    })
    .getTopClients();
}
// Called after (re)rendering the list
function applySuggestionsVisibility() {
  var blocks = document.querySelectorAll('.toplist-suggestion');
  blocks.forEach(function(b) {
    b.style.display = window.__suggestionsVisible ? 'block' : 'none';
  });
}
// === SINGLE SOURCE OF TRUTH: list <- dropdown value ===
function syncClientsListToDropdown(){
  var dd = document.getElementById('topClientsFilterDropdown');
  var val = dd && dd.value ? dd.value : 'JB';
  // Persist current choice + currently-open client (if any)
  try {
    saveUIState({
      filter: val,
      client: (document.getElementById('clientSelect')||{}).value || ''
    });
  } catch(_) {}

  // Stamp today’s date header and clear the title (your existing UI behavior)
  (function setToday(){
    var now = new Date();
    var opts = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
    var formatted = now.toLocaleDateString('en-US', opts).toUpperCase();
    var dt = document.getElementById('dateTitle');
    if (dt) dt.innerText = formatted;
  })();
  (function clearTitle(){
    var titleEl = document.getElementById('topClientsTitle');
    if (!titleEl) return;
    titleEl.innerText = '';
    titleEl.style.display = 'none';
  })();

// Drive the render using a single, token-protected fetch
fetchAndRenderTopClientsFromDropdown();

}

// ===== CANONICAL: Re-render list strictly from dropdown =====
function retriggerTopClientsFilter() {
  // Always go through the same path
  syncClientsListToDropdown();
}

// Safe programmatic setter that also re-renders
function setFilterAndSync(value) {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  dd.value = (value || '').trim();
  syncClientsListToDropdown();
}

// On boot, if nothing is chosen yet, default to JB and immediately sync the list.
(function setInitialTopClientsFilter(){
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  if (!dd.value) dd.value = 'JB';
  syncClientsListToDropdown();
})();






function applyDefaultJBFilter() {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;

  // Select JB in the dropdown (this makes the visible label "JB")
  dd.value = 'JB';

  // Seed the date header and title immediately
  (function seedHeaders(){
    var now = new Date();
    var opts = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
    var formatted = now.toLocaleDateString('en-US', opts).toUpperCase();
    var dt = document.getElementById('dateTitle');
    if (dt) dt.innerText = formatted;

    var tt = document.getElementById('topClientsTitle');
    if (tt) {
      tt.innerText = '';
      tt.style.display = 'none';
    }
  })();

setFilterAndSync('JB'); // uses the canonical path

}



/* ===== PASTE #1 — helpers for soft refresh + wiring ===== */
function refreshTopClientsPreservingScroll() {
  try {
    const y = window.scrollY || 0;
    const dd = document.getElementById('topClientsFilterDropdown');
    const currentFilter = (dd && dd.value) ? dd.value : 'JB';

    google.script.run
      .withSuccessHandler(function (clients) {
        // Repaint with your existing renderer
        showTopClients(clients, currentFilter);

        // Re-wire suggestion textareas so blur-save continues to work
        wireToplistSuggestionTextareas();

        // Keep your Suggestions toggle state
        if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();

        requestAnimationFrame(function () { window.scrollTo(0, y); });
        if (typeof hideLoadingBar === 'function') hideLoadingBar();
      })
      .withFailureHandler(function (err) {
        console.error('refreshTopClientsPreservingScroll error:', err);
        if (typeof hideLoadingBar === 'function') hideLoadingBar();
      })
      .getTopClients();
  } catch (e) {
    console.error('refreshTopClientsPreservingScroll try/catch error:', e);
    if (typeof hideLoadingBar === 'function') hideLoadingBar();
  }
}

/* ===== REPLACEMENT: wireToplistSuggestionTextareas (no full refresh on blur) ===== */
function wireToplistSuggestionTextareas() {
  const nodes = document.querySelectorAll('#topClientsDisplay .toplist-suggestion textarea.note-textarea, #topClientsDisplay .toplist-suggestion textarea.toplist-textarea');

  nodes.forEach(function (ta) {
    // Never let clicks/focus bubble up and cause row-level re-renders
    ['mousedown', 'click', 'focus'].forEach(function(ev){
      ta.addEventListener(ev, function (e) { e.stopPropagation(); }, true);
    });

    // Find the client name (prefer data attribute)
    let clientName = ta.getAttribute('data-client');
    if (!clientName) {
      const host = ta.closest('[data-client]');
      if (host) clientName = host.getAttribute('data-client');
    }
    if (!clientName) {
      const btn = ta.closest('div')?.querySelector('button.inline-button');
      if (btn) clientName = btn.innerText.trim();
    }
    if (!clientName) return; // can't save without a client

    let original = ta.value;
    let dirty = false;

    ta.addEventListener('input', function () {
      dirty = (ta.value !== original);
    });

    // Ctrl/⌘+Enter = quick commit
    ta.addEventListener('keydown', function (e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        ta.blur();
      }
      e.stopPropagation();
    }, true);

    // SAVE ONLY ON BLUR — but DO NOT re-render the whole list
    ta.addEventListener('blur', function () {
      if (!dirty || ta.value.trim() === original.trim()) return;

      if (typeof showLoadingBar === 'function') showLoadingBar();

      google.script.run
        .withSuccessHandler(function () {
          // Keep the screen exactly as-is; just lock in the new value
          original = ta.value;
          dirty = false;

          // Small visual ack near the textarea
          showInlineSavedBadge(ta);

          if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
          if (typeof hideLoadingBar === 'function') hideLoadingBar();
        })
        .withFailureHandler(function (err) {
          alert('Error saving In Progress: ' + (err && err.message ? err.message : err));
          ta.value = original; // revert
          dirty = false;
          if (typeof hideLoadingBar === 'function') hideLoadingBar();
        })
        // ⬇️ CHANGE THIS if your server save function has a different name
        .updateClientColumnL(clientName, ta.value);
    }, true);
  });
}
/* ===== END REPLACEMENT ===== */

/* Tiny helper for a subtle "Saved" badge */
function showInlineSavedBadge(textarea) {
  try {
    let badge = document.createElement('span');
    badge.textContent = 'Saved';
    badge.style.marginLeft = '8px';
    badge.style.fontSize = '0.8em';
    badge.style.opacity = '0.85';
    badge.style.background = '#e8f5e9';
    badge.style.border = '1px solid #c8e6c9';
    badge.style.borderRadius = '10px';
    badge.style.padding = '2px 8px';
    // place after textarea
    let parent = textarea.parentNode;
    parent.appendChild(badge);
    setTimeout(() => { badge.remove(); }, 1500);
  } catch (_) {}
}

/* ===== END PASTE #1 ===== */

// Initial setup of button colors

document.getElementById('immediateBtn').style.backgroundColor = '#FFCCCC';
document.getElementById('pendingBtn').style.backgroundColor = '#FFFFCC';
document.getElementById('deferredBtn').style.backgroundColor = '#FFD9B3';
document.getElementById('adjustableBtn').style.backgroundColor = '#ADD8E6';




var clientsData = [];
/* ===== NAME LINKIFY + HOVER BUBBLE HELPERS ===== */
var __clientNames = [];           // Full client names (Column A)
var __nameTokens = [];            // Unique tokens from names (first/last/etc., len > 3)
var __nameUnionRegex = null;      // Combined regex (longest-first) of full names + tokens
var __hideBubbleTimer = null;

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function escapeHTML(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/** Split a full name into reasonable tokens (letters, digits, apostrophes, hyphens). */
function tokenizeNameParts(name) {
  // Split on anything that’s NOT allowed inside a name token
  // (space, commas, slashes, ampersands, periods, etc.)
  return String(name)
    .split(/[^A-Za-z0-9'-]+/)
    .map(t => t.trim())
    .filter(t => t.length > 3); // only >3 chars per your rule
}

/** Build the master arrays + union regex from clientsData (Column A). */
function rebuildClientNameIndex() {
  try {
    // 1) Collect full names (>3 chars)
    __clientNames = (clientsData || [])
      .map(c => (c && c.clientName) ? String(c.clientName).trim() : '')
      .filter(n => n && n.length > 3);

    // Dedupe full names (case-insensitive)
    const seenFull = new Set();
    __clientNames = __clientNames.filter(n => {
      const key = n.toLowerCase();
      if (seenFull.has(key)) return false;
      seenFull.add(key);
      return true;
    });

    // 2) Tokenize into first/last/etc. (>3 chars), dedupe
    const tokenSet = new Set();
    __clientNames.forEach(n => {
      tokenizeNameParts(n).forEach(tok => tokenSet.add(tok));
    });
    __nameTokens = Array.from(tokenSet);

    // 3) Combine (full names + tokens), longest-first to prefer full names when contiguous
    const parts = Array.from(new Set(
      __clientNames.concat(__nameTokens).map(escapeRegex)
    )).sort((a, b) => b.length - a.length);

    __nameUnionRegex = parts.length
      ? new RegExp('(?:^|\\b)(' + parts.join('|') + ')(?:\\b|$)', 'gi')
      : null;
  } catch (e) {
    console.error('rebuildClientNameIndex error:', e);
    __clientNames = [];
    __nameTokens = [];
    __nameUnionRegex = null;
  }
}

/** Wrap occurrences of full names OR known tokens with span.client-mention. */
function linkifyText(plainEscaped) {
  if (!__nameUnionRegex) return plainEscaped;
  // plainEscaped is already escaped; replacing safe text substrings is fine.
  return plainEscaped.replace(__nameUnionRegex, function (_full, captured) {
    const shown = captured;
    return '<span class="client-mention" data-fragment="' + escapeHTML(shown) + '">' + escapeHTML(shown) + '</span>';
  });
}
// === DATE BOLDING + SAFE NOTE HTML PIPELINE ===
// We work on *escaped* text so we can safely inject <strong> tags.
// Matches leading or standalone dates like 6/6/24, 06/06/24, 06/06/2024 (optionally followed by a colon).
function boldDatesEscaped(escapedText) {
  if (!escapedText) return escapedText;

  // 1) Bold a date at the very start of a line (beginning or after a <br>)
  const startOfLineDate = /(^|<br\s*\/?>)\s*(\d{1,2}\/\d{1,2}\/\d{2,4})(?=\b:?\s)/g;
  let out = escapedText.replace(startOfLineDate, function(_, br, date) {
    return (br || '') + '<strong>' + date + '</strong>';
  });

  // 2) Also bold any other date tokens that appear elsewhere in the line (optional; keep if you want all dates bold)
  const anyDate = /\b(\d{1,2}\/\d{1,2}\/\d{2,4})\b/g;
  out = out.replace(anyDate, function(match) {
    // Avoid double-wrapping if already bolded
    if (/^<strong>.*<\/strong>$/.test(match)) return match;
    return '<strong>' + match + '</strong>';
  });

  return out;
}

// Given a *plain* note string, return safe HTML with bolded dates and linkified names/tokens.
function formatNoteHTML(plainText) {
  const escaped = escapeHTML(String(plainText || ''));
  const withBoldDates = boldDatesEscaped(escaped);
  // Reuse your existing name linkifier on the escaped+bolded text
  return linkifyText(withBoldDates);
}

// PASTE THIS WHOLE BLOCK **IMMEDIATELY AFTER** the closing brace of formatNoteHTML(...)
// (i.e., after: function formatNoteHTML(plainText) { ... })
function renderNoteLine(lineText, chipHTML) {
  // lineText is the original plain text for the note line (no HTML)
  // chipHTML is a string like `<span class="chip ...">...</span>` or '' if none
  const safeNoteHTML = formatNoteHTML(lineText);
  return chipHTML ? (safeNoteHTML + ' ' + chipHTML) : safeNoteHTML;
}


/** Attach hover/click handlers to mentions inside a container. */
function attachMentionHandlers(container) {
  if (!container) return;
  const mentions = container.querySelectorAll('.client-mention');
  mentions.forEach(function (el) {
    el.addEventListener('click', function (e) {
      e.stopPropagation();
      const frag = (el.getAttribute('data-fragment') || '').trim();
      if (!frag) return;

      // If the fragment exactly equals a full client name, load it directly.
      const exact = __clientNames.find(n => n.toLowerCase() === frag.toLowerCase());
      if (exact) {
        selectClientFromButton(exact);
        scrollToTop();
        hideNameBubble();
        return;
      }

      // Otherwise show chooser bubble anchored to this token.
      showNameBubbleForFragment(frag, el.getBoundingClientRect());
    });

    el.addEventListener('mouseenter', function (e) {
      e.stopPropagation();
      const frag = (el.getAttribute('data-fragment') || '').trim();
      showNameBubbleForFragment(frag, el.getBoundingClientRect());
    });

    el.addEventListener('mousemove', function (e) {
      positionBubbleNearMouse(e.clientX, e.clientY);
    });

    el.addEventListener('mouseleave', function () {
      scheduleHideNameBubble();
    });
  });
}

/** Build the suggestion list for the hovered fragment and show bubble. */
function showNameBubbleForFragment(fragment, rect) {
  clearTimeout(__hideBubbleTimer);
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble) return;

  const term = String(fragment || '').trim();
  if (!term) {
    bubble.style.display = 'none';
    return;
  }

  // Primary: names that include the fragment (case-insensitive)
  const lc = term.toLowerCase();
  const set = new Set();
  let candidates = __clientNames.filter(n => {
    const keep = n.toLowerCase().indexOf(lc) !== -1;
    if (keep) set.add(n);
    return keep;
  });

  // If fewer than 10 and the fragment has multiple words, also expand by each part
  if (candidates.length < 10 && /\s+/.test(term)) {
    const parts = term.split(/\s+/).map(s => s.trim()).filter(s => s.length > 3);
    parts.forEach(function (p) {
      const plc = p.toLowerCase();
      __clientNames.forEach(function (n) {
        if (set.size < 10 && n.toLowerCase().indexOf(plc) !== -1) set.add(n);
      });
    });
    candidates = Array.from(set);
  }

  candidates = candidates.slice(0, 10);

  let html = '<div class="bubble-title">Related to “' + escapeHTML(term) + '”</div>';
  if (!candidates.length) {
    html += '<div class="bubble-item" style="opacity:.7; cursor:default;">No matches</div>';
  } else {
    candidates.forEach(function (name) {
      html += '<div class="bubble-item" data-name="' + escapeHTML(name) + '">' + escapeHTML(name) + '</div>';
    });
  }
  bubble.innerHTML = html;

  // Click on an item loads that client.
  bubble.querySelectorAll('.bubble-item').forEach(function (item) {
    item.addEventListener('click', function (e) {
      e.stopPropagation();
      const nm = item.getAttribute('data-name');
      if (nm && nm !== 'No matches') {
        selectClientFromButton(nm);
        scrollToTop();
      }
      hideNameBubble();
    });
  });

  // Keep bubble alive while hovering it
  bubble.onmouseenter = function () {
    clearTimeout(__hideBubbleTimer);
  };
  bubble.onmouseleave = function () {
    scheduleHideNameBubble();
  };

  bubble.style.display = 'block';
  positionBubbleByRect(rect);
}

// Negative X shifts left; tweak as you like
const NAME_BUBBLE_OFFSETS = {
  rectX: -20,  // when first showing (by rect)
  rectY: 6,
  mouseX: -24, // when following the mouse
  mouseY: 8
};

function positionBubbleByRect(rect) {
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble || !rect) return;

  const padding = 8;
  const x = rect.left + window.scrollX + (NAME_BUBBLE_OFFSETS?.rectX || 0);
  const y = rect.bottom + window.scrollY + (NAME_BUBBLE_OFFSETS?.rectY || 0);

  const maxLeft = window.scrollX + document.documentElement.clientWidth - bubble.offsetWidth - padding;
  const maxTop  = window.scrollY + document.documentElement.clientHeight - bubble.offsetHeight - padding;

  bubble.style.left = Math.max(window.scrollX + padding, Math.min(x, maxLeft)) + 'px';
  bubble.style.top  = Math.max(window.scrollY + padding, Math.min(y, maxTop)) + 'px';
}

function positionBubbleNearMouse(clientX, clientY) {
  const bubble = document.getElementById('nameHoverBubble');
  if (!bubble || bubble.style.display !== 'block') return;

  const padding = 8;
  const x = clientX + window.scrollX + (NAME_BUBBLE_OFFSETS?.mouseX || 0);
  const y = clientY + window.scrollY + (NAME_BUBBLE_OFFSETS?.mouseY || 0);

  const maxLeft = window.scrollX + document.documentElement.clientWidth - bubble.offsetWidth - padding;
  const maxTop  = window.scrollY + document.documentElement.clientHeight - bubble.offsetHeight - padding;

  bubble.style.left = Math.max(window.scrollX + padding, Math.min(x, maxLeft)) + 'px';
  bubble.style.top  = Math.max(window.scrollY + padding, Math.min(y, maxTop)) + 'px';
}


function scheduleHideNameBubble() {
  clearTimeout(__hideBubbleTimer);
  __hideBubbleTimer = setTimeout(hideNameBubble, 220);
}

function hideNameBubble() {
  const bubble = document.getElementById('nameHoverBubble');
  if (bubble) bubble.style.display = 'none';
}
/* ===== END NAME LINKIFY + HOVER BUBBLE HELPERS ===== */

/*** DASHBOARD TASKS loader/renderer ***/
function showTasksFromSpreadsheet() {
  var container = document.getElementById('updateTasksContainer');
  var box = document.getElementById('tasksList');
  if (!box) return;

  // make sure it’s visible
  if (container) container.style.display = 'block';

  box.innerHTML = '<div style="opacity:.7;font-style:italic;">Loading tasks…</div>';

  google.script.run
    .withSuccessHandler(function(rows) {
      renderTasksFromDashboardIntegration(rows);
    })
    .withFailureHandler(function(err) {
      box.innerHTML = '<div style="color:red;">Failed to load tasks: ' +
                      (err && err.message ? err.message : err) + '</div>';
    })
    .getTasksForDashboardIntegration();
}

function renderTasksFromDashboardIntegration(rows) {
  var box = document.getElementById('tasksList');
  if (!box) return;

  if (!rows || !rows.length) {
    box.innerHTML = '<div style="opacity:.7;">No tasks found in Tasks!A2:A.</div>';
    return;
  }

  var html = rows.map(function(t) {
    var txt = (t && t.fullTask) ? String(t.fullTask) : '';
    var row = (t && t.rowIdInTasks) ? t.rowIdInTasks : '';
    return (
      '<div class="task-display" data-row="'+ row +'">' +
        '<div><strong>' + escapeHtmlForTasks(txt) + '</strong></div>' +
        '<div style="margin-top:8px;"><button type="button" onclick="deleteTaskCard('+ row +')">Delete</button></div>' +
      '</div>'
    );
  }).join('');

  box.innerHTML = html;
}

function deleteTaskCard(rowIndex) {
  if (!rowIndex) return;
  if (!confirm('Delete this task (row ' + rowIndex + ')?')) return;

  google.script.run
    .withSuccessHandler(function() {
      showTasksFromSpreadsheet(); // refresh after delete
    })
    .withFailureHandler(function(err) {
      alert('Failed to delete: ' + (err && err.message ? err.message : err));
    })
    .deleteTaskRow(rowIndex);
}

function escapeHtmlForTasks(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}


document.addEventListener('DOMContentLoaded', function() {
    showLoadingBar(); // Show the loading bar
    /***** SNIPPET: IMMEDIATELY SHOW DATE & EMAIL SUMMARY BUTTON *****/
{
  // Get today's date in short format
  var now = new Date();
  var opts = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
  var formattedDate = now.toLocaleDateString('en-US', opts).toUpperCase();
  
  // Set the #dateTitle text right away
  document.getElementById('dateTitle').innerText = formattedDate;

  // Force the EMAIL SUMMARY button to be visible immediately
  // (In case any default CSS hides it, this ensures it's displayed.)
document.getElementById('scrollBottomBtn').style.display = 'inline-block';
}
/***** END SNIPPET *****/

    google.script.run.withSuccessHandler(function(data){
      clientsData = data;
      rebuildClientNameIndex();

      populateClientDropdown(clientsData); // Update the dropdown with the client data
      hideLoadingBar(); // Hide the loading bar after populating the dropdown
    }).getAllClientsData();
    google.script.run.withSuccessHandler(populateLabelsDropdown).getAllLabels();
    handleUserSelectionChange();
    updateCategoryLabel(); // Initialize the category label
    displayTable(); // Call displayTable here instead of using window.onload
        google.script.run.withSuccessHandler(function(categories) {
        populateCategoryDropdown(categories);
    }).getUniqueCategories();
        showTasksFromSpreadsheet(); 

});

document.addEventListener('DOMContentLoaded', function() {
    adjustBodyMarginTop();
});



window.addEventListener('resize', adjustBodyMarginTop);

function adjustBodyMarginTop() {
    var clientContainer = document.querySelector('.client-container');
    var clientContainerHeight = clientContainer.offsetHeight;
    document.body.style.marginTop = clientContainerHeight + 'px';
}
// === AUTO-SPACING FOR FIXED HEADER (keeps date/labels/buttons visible) ===
// This re-runs the margin-top sizing whenever the blue box height changes.
function ensureHeaderSpacing() {
  // run a few times across the paint cycle to catch async/layout changes
  try {
    adjustBodyMarginTop();
    requestAnimationFrame(adjustBodyMarginTop);
    setTimeout(adjustBodyMarginTop, 0);
  } catch (e) {}
}

(function () {
  var header = document.querySelector('.client-container');
  if (!header) return;

  // 1) Watch the header itself for size changes (chips wrapping, etc.)
  if ('ResizeObserver' in window) {
    var ro = new ResizeObserver(ensureHeaderSpacing);
    ro.observe(header);
  }

  // 2) Watch the recent chips container for DOM changes
  var recent = document.getElementById('recentClientsBar');
  if (recent && 'MutationObserver' in window) {
    var mo = new MutationObserver(ensureHeaderSpacing);
    mo.observe(recent, { childList: true, subtree: true, attributes: true });
  }

  // 3) Also bump spacing on key UI interactions that can affect height
  ['input', 'click'].forEach(function (ev) {
    var el = document.getElementById('clientAutocomplete');
    if (el) el.addEventListener(ev, ensureHeaderSpacing, true);
  });

  // 4) Run once after load
  window.addEventListener('load', ensureHeaderSpacing);
})();


var currentClientName = '';

var inputElement = document.getElementById('clientAutocomplete');

inputElement.addEventListener('click', function() {
    if (inputElement.value === currentClientName) {
        inputElement.style.color = 'lightgray'; // Set text color to gray when clicked
    }
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
        hideClientNotes(); // Call the function when the input is clicked into

});

inputElement.addEventListener('input', function() {
    if (inputElement.value !== currentClientName) {
        inputElement.style.color = 'black'; // Set text color to black when typing new text
    }
});

inputElement.addEventListener('blur', function() {
    if (inputElement.value === '') {
        inputElement.value = currentClientName;
        inputElement.style.color = 'black'; // Restore text color to black
    }
});

var suggestions = null;

// Add the click event listener here
inputElement.addEventListener('click', function() {
    inputElement.value = ''; // Clear the input field
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
});

inputElement.addEventListener('keydown', function(e) {
    if (!suggestions) return; // No suggestions to navigate

    var currentFocus = suggestions.querySelector('.autocomplete-active');
    if (e.key === "ArrowDown") {
        // Handle down arrow key
        if (currentFocus) {
            if (currentFocus === suggestions.lastChild) {
                // Move cursor to the left of the first character in the textarea
                inputElement.focus();
                inputElement.selectionStart = 0;
                inputElement.selectionEnd = 0;
                currentFocus.classList.remove('autocomplete-active');
            } else {
                // Move to next suggestion
                currentFocus.classList.remove('autocomplete-active');
                var next = currentFocus.nextElementSibling;
                if (next) {
                    next.classList.add('autocomplete-active');
                    next.scrollIntoView({ block: 'nearest' });
                }
            }
        } else {
            // No option is highlighted, cursor is in the textarea
            if (document.activeElement === inputElement) {
                // Highlight first suggestion
                if (suggestions.firstChild) {
                    suggestions.firstChild.classList.add('autocomplete-active');
                    suggestions.firstChild.scrollIntoView({ block: 'nearest' });
                }
            }
        }
        e.preventDefault();
    } else if (e.key === "ArrowUp") {
        // Handle up arrow key
        if (currentFocus) {
            if (currentFocus === suggestions.firstChild) {
                // Move cursor to the left of the first character in the textarea
                inputElement.focus();
                inputElement.selectionStart = 0;
                inputElement.selectionEnd = 0;
                currentFocus.classList.remove('autocomplete-active');
            } else {
                // Move to previous suggestion
                currentFocus.classList.remove('autocomplete-active');
                var prev = currentFocus.previousElementSibling;
                if (prev) {
                    prev.classList.add('autocomplete-active');
                    prev.scrollIntoView({ block: 'nearest' });
                }
            }
        } else {
            // No option is highlighted, cursor is in the textarea
            if (document.activeElement === inputElement) {
                // Highlight last suggestion
                if (suggestions.lastChild) {
                    suggestions.lastChild.classList.add('autocomplete-active');
                    suggestions.lastChild.scrollIntoView({ block: 'nearest' });
                }
            }
        }
        e.preventDefault();
    } else if (e.key === "Enter") {
        // Handle enter key
        e.preventDefault();
        if (currentFocus) {
            currentFocus.click();
        }
    }
});







function selectButton(buttonId, selectedColor, clientFilter) {
  // Reset all button colors
  document.getElementById('immediateBtn').style.backgroundColor = '#FFCCCC';
  document.getElementById('pendingBtn').style.backgroundColor = '#FFFFCC';
  document.getElementById('deferredBtn').style.backgroundColor = '#FFD9B3';
  document.getElementById('adjustableBtn').style.backgroundColor = '#ADD8E6';

  // Highlight selected
  document.getElementById(buttonId).style.backgroundColor = selectedColor;

  // If these buttons are meant to scope a different panel, call that logic here.
  // Do NOT touch the Top Clients filter list directly; it’s driven only by the dropdown.
}


document.addEventListener('DOMContentLoaded', function fastFirstPaint() {
  // 1) Kick Top Clients request FIRST so it paints ASAP
  google.script.run.withSuccessHandler(function(clients){
    // Initial render (same layout/order you already use)
showTopClientsOnLoad(
  clients,
  (document.getElementById('topClientsFilterDropdown')?.value || 'JB')
);
// === PATCH 1: Wire "Ricky's Suggestion" textareas after first paint ===
if (typeof wireToplistSuggestionTextareas === 'function') {
  wireToplistSuggestionTextareas();
}

    // 2) Next tick: wire the filter after list is visible (no re-defaulting, just wiring)
    requestAnimationFrame(initTopClientsFilterAfterList);
  }).getTopClients();

  // ⛔ Removed: the extra setTimeout(…, 0) that also called:
  //   - getAllClientsData() + rebuildClientNameIndex() + populateClientDropdown()
  //   - getAllLabels() + populateLabelsDropdown()
  // We keep those calls ONLY in your main DOMContentLoaded boot block.
});

// === PATCH 2: Auto-rewire textareas after any Top Clients re-render ===
(function () {
  var root = document.getElementById('topClientsDisplay');
  if (!root || !('MutationObserver' in window)) return;

  var rewire = function () {
    if (typeof wireToplistSuggestionTextareas === 'function') {
      wireToplistSuggestionTextareas();
    }
  };

  // Rewire now (in case PATCH 1 runs before the node exists)
  rewire();

  // Any child list change → rewire textareas so blur-save stays “no-refresh”
  var mo = new MutationObserver(function () { rewire(); });
  mo.observe(root, { childList: true, subtree: true });
})();



/* PASTE #3 — ignore clicks inside suggestion blocks */
document.addEventListener('DOMContentLoaded', function () {
  var wrap = document.getElementById('topClientsDisplay');

// === PATCH 3: Harden click guard inside Top Clients list ===
(function () {
  var wrap = document.getElementById('topClientsDisplay');
  if (!wrap) return;

  // Capture phase to stop *before* row handlers see the event.
  wrap.addEventListener('mousedown', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);

  wrap.addEventListener('click', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);

  wrap.addEventListener('focusin', function (e) {
    if (e.target.closest('.toplist-suggestion')) e.stopPropagation();
  }, true);
})();



  if (!wrap) return;
  wrap.addEventListener('click', function(e){
    if (e.target.closest('.toplist-suggestion')) {
      // Don’t let row/card click handlers do anything while editing the textarea
      e.stopPropagation();
      return;
    }
  }, true);
});

window.addEventListener('load', function(){
  // Next tick: restore prior state, then ensure list matches dropdown
  setTimeout(function(){
    if (typeof restoreUIState === 'function') restoreUIState();
    syncClientsListToDropdown();
  }, 0);
});


function initTopClientsFilterAfterList(){
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  if (!dd._wired) {
    dd.addEventListener('change', function(){
      // Single source of truth: always go through syncClientsListToDropdown
      syncClientsListToDropdown();
    });
    dd._wired = true;
  }
}







   document.getElementById('loadNotesButton').addEventListener('click', function() {
        google.script.run.withSuccessHandler(displayTodayNotes).getTodayNotes();
      });

    // Load the Visualization API and the corechart package.
    google.charts.load('current', {packages: ['corechart']});

    // Set a callback to run when the Google Visualization API is loaded.
    google.charts.setOnLoadCallback(getAndDrawHeatmapData);
        google.charts.setOnLoadCallback(drawScatterPlot);


    // ... rest of your JavaScript functions ...





      // Populate client dropdown
function populateClientDropdown(clients) {
    var clientSelect = document.getElementById('clientSelect');
    clientSelect.innerHTML = ''; // Clear existing options first

    // Add a blank default option
    var defaultOption = document.createElement('option');
    defaultOption.textContent = 'Select a Client'; // Text for the placeholder option
    defaultOption.value = ''; // No value for the placeholder option
    defaultOption.disabled = true; // Make the placeholder option disabled
    defaultOption.selected = true; // Make the placeholder option selected by default
    clientSelect.appendChild(defaultOption);

    // Add the client options
    clients.forEach(function(client) {
        var option = document.createElement('option');
        option.value = client.clientName;
        option.textContent = client.clientName + (client.category ? ' (' + client.category + ')' : '');
        clientSelect.appendChild(option);
    });
    hideLoadingBar(); // Hide the loading bar after populating the dropdown
}

// Event listener for STRICT/FLEXIBLE dropdown (guarded)
(function() {
  var el = document.getElementById('columnBDropdown');
  if (!el) return;
  el.addEventListener('change', function() {
    showLoadingBar();
    updateSettings(this.value).then(() => {
      hideLoadingBar();
    }).catch((error) => {
      console.error("Failed to update settings: ", error);
      hideLoadingBar();
    });
  });
})();

// Event listener for day of the week dropdown (guarded)
(function() {
  var el = document.getElementById('columnDDropdown');
  if (!el) return;
  el.addEventListener('change', function() {
    showLoadingBar();
    updateDaySettings(this.value).then(() => {
      hideLoadingBar();
    }).catch((error) => {
      console.error("Failed to update day settings: ", error);
      hideLoadingBar();
    });
  });
})();


function updateSettings(value) {
    // Replace with actual code to handle the change in settings
    return new Promise((resolve, reject) => {
        // Simulate asynchronous operation with setTimeout
        setTimeout(() => {
            resolve();
        }, 1000); // Simulate a delay of 1 second
    });
}

function updateDaySettings(value) {
    // Replace with actual code to handle the change in day settings
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, 1000); // Simulate a delay of 1 second
    });
}


// Show client notes and update category label
function showClientNotes() {
    var clientName = document.getElementById('clientSelect').value;
     if (clientName) {
    onClientOpened(clientName); // <-- add this
  }
    var clientSelect = document.getElementById('clientSelect');
    var clientAutocomplete = document.getElementById('clientAutocomplete');
    // SNIPPET: CLEAR LOADED IN-PROGRESS AREA
    // So we don't see old text while the new client data is loading
    document.getElementById('loadedInProgressArea').value = '';

    // Set the autocomplete value based on the dropdown selection
    clientAutocomplete.value = clientName ? clientSelect.options[clientSelect.selectedIndex].text : '';

    if (clientName) {
        clientAutocomplete.style.color = 'black'; // Set text color to black when client is loaded
        currentClientName = clientAutocomplete.value; // Store the current client name
    } else {
        clientAutocomplete.style.color = ''; // Default color
        currentClientName = '';
    }
// Reset values and set displays based on selection
document.getElementById('newPastWork').value = '';
document.getElementById('categorySelect').value = '';

var displayStyle = clientName ? 'block' : 'none';

// Show only the Past Work section (Future Work is deprecated)
document.getElementById('workSectionsContainer').style.display = clientName ? 'flex' : 'none';
document.getElementById('pastWorkSection').style.display = displayStyle;

// Hide deprecated Future Work UI if it still exists (safety)
var fw = document.getElementById('futureWorkSection');
if (fw) fw.style.display = 'none';

// Keep the rest of the UI behavior unchanged
document.getElementById('categoryChangeSection').style.display = displayStyle;
document.getElementById('appointmentInputSection').style.display = 'none';
document.getElementById('addAppointmentBtn').style.display = displayStyle;
document.getElementById('labelsAdditionSection').style.display = displayStyle;
document.getElementById('hideClientNotesBtn').style.display = displayStyle; // Show or hide the button
document.getElementById('notesDisplay').style.display = 'block';


    updateCategoryLabel();

    // **Show loading bar before starting asynchronous operations**
    showLoadingBar();

    // **Create a counter for pending async operations**
    var pendingOps = 2;

    // Start asynchronous operation to populate labels dropdown
    google.script.run.withSuccessHandler(function(labels) {
        populateLabelsDropdown(labels);
        pendingOps--;
        if (pendingOps === 0) {
            hideLoadingBar();
        }
    }).getAllLabels();

    // Fetch client details and handle them with a success handler
    google.script.run.withSuccessHandler(function(data) {
        // After successful fetch, set up the dropdowns and display data
     // After successful fetch, set up the dropdowns and display data
setupColumnDropdowns(data);

// ⭐ Set chip cache FIRST (so displayNotes sees it)
window.__chipForCurrentClient = {
  initials: (data.chipInitials || "").toUpperCase(),
  date: data.chipDate || ""   // already MM/DD/YY per our server plan
};

displayClientDetails(data);

// Update the category select value based on fetched client data
updateCategorySelectValue(data.category);

        pendingOps--;
        if (pendingOps === 0) {
            hideLoadingBar();
        }
    }).getClientDetails(clientName);

    // Persist "which client is open" along with current filter
saveUIState({
  filter: (document.getElementById('topClientsFilterDropdown')||{}).value || '',
  client: (document.getElementById('clientSelect')||{}).value || ''
});

}


var inputElement = document.getElementById('clientAutocomplete');
var suggestions = null;

// Clear the input and reset text color when clicked
inputElement.addEventListener('click', function() {
    inputElement.value = ''; // Clear the input field
    inputElement.style.color = ''; // Reset color to default
    if (suggestions) {
        suggestions.innerHTML = ''; // Clear existing suggestions
    }
});

// Reset text color when the user types
inputElement.addEventListener('input', function() {
    inputElement.style.color = ''; // Reset color to default
});

function setupColumnDropdowns(data) {
    setupColumnBDropdown(data);
    setupColumnDDropdown(data);
}

function normalizeTopClientsFilter(val) {
  const raw = (val || '').toString().trim();
  // Map emojis/aliases to canonical keys your renderer understands
  const map = {
    'JB':'JB', 'RB':'RB', 'QC':'QC', 'TEAM':'TEAM',
    '💼':'BRIEFCASE', '⭐':'STAR', '🎓':'GRADCAP', '📞':'PHONE'
  };
  return map.hasOwnProperty(raw) ? map[raw] : raw.toUpperCase();
}

function setupColumnBDropdown(data) {
  var columnBDropdown = document.getElementById('columnBDropdown');
  if (!columnBDropdown) return; // Future Work UI removed
  columnBDropdown.innerHTML = '';
  var blankOption = document.createElement('option');
  blankOption.value = "";
  columnBDropdown.appendChild(blankOption);
  ['STRICT', 'FLEXIBLE'].forEach(function(optionValue) {
    var option = document.createElement('option');
    option.value = optionValue;
    option.text = optionValue;
    columnBDropdown.appendChild(option);
  });
  columnBDropdown.value = data.columnB || "";
}


function setupColumnDDropdown(data) {
  var columnDDropdown = document.getElementById('columnDDropdown');
  if (!columnDDropdown) return; // Future Work UI removed
  columnDDropdown.innerHTML = '';
  ['','Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'].forEach(function(day) {
    var option = document.createElement('option');
    option.value = day;
    option.text = day;
    columnDDropdown.appendChild(option);
  });
  columnDDropdown.value = data.columnD || "";
}

function displayClientDetails(data) {
    var labelsDisplay = document.getElementById('labelsDisplay');
    labelsDisplay.innerHTML = '';
    if (data.notes) {
        displayNotes(data.notes);
    }
displayLabels(Array.isArray(data.labels) ? data.labels : []);

// SNIPPET #4: Ensure the loaded "In Progress:" is set from data.columnL
// Seed the In Progress textarea and remember the last-saved value
var loadedInProgressArea = document.getElementById('loadedInProgressArea');
var seed = data.columnL || '';
loadedInProgressArea.value = seed;
loadedInProgressArea.setAttribute('data-last-saved', seed);

// Prevent clicks/focus from bubbling and triggering any container logic
['mousedown','click','focus','keydown'].forEach(function(ev){
  loadedInProgressArea.addEventListener(ev, function(e){
    // Ctrl/Cmd+Enter commits quickly
    if ((ev === 'keydown') && ((e.ctrlKey || e.metaKey) && e.key === 'Enter')) {
      e.preventDefault();
      loadedInProgressArea.blur(); // triggers save
      return;
    }
    e.stopPropagation();
  }, true);
});

loadedInProgressArea.value = seed;
loadedInProgressArea.setAttribute('data-last-saved', seed);

// Prevent clicks/focus from bubbling and triggering any container logic
['mousedown','click','focus','keydown'].forEach(function(ev){
  loadedInProgressArea.addEventListener(ev, function(e){
    // Allow Ctrl/Cmd+Enter to commit quickly
    if ((ev === 'keydown') && ((e.ctrlKey || e.metaKey) && e.key === 'Enter')) {
      e.preventDefault();
      loadedInProgressArea.blur(); // triggers safe save
      return;
    }
    e.stopPropagation();
  }, true);
});
// === Paste this as the LAST line inside your "client notes are ready" function ===
loadCategoriesForClientAfterNotes();


}







function displayLabels(labelsArray) {
    var labelsDisplay = document.getElementById('labelsDisplay');
    labelsDisplay.innerHTML = '';

    labelsArray.forEach(function(labelObj) {
        var labelDiv = document.createElement('div');
        labelDiv.className = 'label-box';
        labelDiv.textContent = labelObj.label;

        // Apply light blue background and black text to labels from columns H-K
        if (labelObj.isBlue) {
            labelDiv.style.backgroundColor = 'lightblue';
            labelDiv.style.color = 'black';
        } else {
            // Set the background to light green for labels that are not light blue
            labelDiv.style.backgroundColor = 'lightgreen';

            // Only add onclick event if the background is not blue
            labelDiv.onclick = function() {
                confirmAndRemoveLabel(labelObj.label);
            };
        }

        labelsDisplay.appendChild(labelDiv);
    });
}






function confirmAndRemoveLabel(label) {
    var clientName = document.getElementById('clientSelect').value;
    if (confirm('Are you sure you want to remove the label "' + label + '" from ' + clientName + '?')) {
        google.script.run.withSuccessHandler(function() {
            alert('Label removed successfully!');
            showClientNotes(); // Assuming this function refreshes client details
        }).withFailureHandler(function(error) {
            alert('Error removing label: ' + error.message);
        }).removeLabelFromClient(clientName, label);
    }
}

function openNewCategoryModal() {
  var m = document.getElementById('newCategoryModal');
  if (m) {
    document.getElementById('newCategoryInput').value = '';
    m.style.display = 'block';
  }
}

function closeNewCategoryModal() {
  var m = document.getElementById('newCategoryModal');
  if (m) m.style.display = 'none';
}

// When user confirms a new category: set dropdown to it and persist via updateCategory()
function confirmNewCategory() {
  var input = document.getElementById('newCategoryInput');
  var name = (input ? String(input.value || '').trim() : '');
  if (!name) {
    alert('Please type a category name.');
    return;
  }

  // Set the dropdown to the new value, close modal, then save
  var sel = document.getElementById('categorySelect');
  closeNewCategoryModal();

  // Add it to the dropdown immediately for this session
  // (it will be truly "permanent" after we save it to the client and re-pull unique categories)
  if (sel) {
    var exists = Array.from(sel.options).some(function(opt){ return opt.value.toLowerCase() === name.toLowerCase(); });
    if (!exists) {
      var opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      // insert alphabetically before the sentinel NEW CATEGORY…
      var inserted = false;
      for (var i = 0; i < sel.options.length; i++) {
        var o = sel.options[i];
        if (o.value && o.value !== '__NEW__' && o.value.localeCompare(name, 'en', {sensitivity:'base'}) > 0) {
          sel.add(opt, o);
          inserted = true;
          break;
        }
      }
      if (!inserted) sel.add(opt, sel.querySelector('option[value="__NEW__"]') || null);
    }
    sel.value = name;
  }

  // Persist: assign this new category to the currently loaded client
  // Your existing updateCategory() reads #categorySelect and #clientSelect
  updateCategory();
  updateCategoryLabel();

  // Refresh master list so the new category appears next time (pulls Column F uniques)
  google.script.run
    .withSuccessHandler(function(categories){
      populateCategoryDropdown(categories);
      // keep the just-saved value selected
      var sel2 = document.getElementById('categorySelect');
      if (sel2) sel2.value = name;
    })
    .getUniqueCategories();
}

/* Save the selected dropdown category to Column F for the currently loaded client. */
function updateCategory() {
  var clientSel = document.getElementById('clientSelect');
  var catSel    = document.getElementById('categorySelect');
  if (!clientSel || !catSel) return;

  var clientName = String(clientSel.value || '').trim();
  var category   = String(catSel.value || '').trim();

  if (!clientName) {
    alert('Please select a client first.');
    return;
  }
  if (!category) {
    alert('Please pick a category.');
    return;
  }

  // Visual feedback (optional)
  if (typeof showLoadingBar === 'function') showLoadingBar();

google.script.run
  .withSuccessHandler(function(res){
    if (typeof hideLoadingBar === 'function') hideLoadingBar();

    if (typeof updateCategoryLabel === 'function') updateCategoryLabel();

    // ⬇️ re-run the Top Clients filter now
    retriggerTopClientsFilter();

    google.script.run
      .withSuccessHandler(function(categories){
        if (typeof populateCategoryDropdown === 'function') {
          populateCategoryDropdown(categories);
          var sel = document.getElementById('categorySelect');
          if (sel) sel.value = category;
        }
      })
      .getUniqueCategories();
  })

    .withFailureHandler(function(err){
      if (typeof hideLoadingBar === 'function') hideLoadingBar();
      alert('Failed to save category: ' + (err && err.message ? err.message : err));
    })
    .updateClientCategory(clientName, category);
}

function populateCategoryDropdown(categories) {
  var sel = document.getElementById('categorySelect');
  if (!sel) return;

  // Reset options
  sel.innerHTML = '';

  // Placeholder
  var ph = document.createElement('option');
  ph.value = '';
  ph.textContent = 'Select a category...';
  sel.appendChild(ph);

  // Categories
  (categories || []).forEach(function (cat) {
    var opt = document.createElement('option');
    opt.value = cat;
    opt.textContent = cat;
    sel.appendChild(opt);
  });

  // Sentinel at end
  var newOpt = document.createElement('option');
  newOpt.value = '__NEW__';
  newOpt.textContent = 'NEW CATEGORY…';
  sel.appendChild(newOpt);

  // 🔧 Wire up change handler ONCE
  if (!sel._wiredChange) {
    sel.addEventListener('change', function () {
      if (this.value === '__NEW__') {
        // open modal and keep dropdown at placeholder
        this.value = '';
        openNewCategoryModal();
        return;
      }
      if (this.value) {
        // save to sheet and refresh the little label if you show one
        updateCategory();
        if (typeof updateCategoryLabel === 'function') updateCategoryLabel();
      }
    });
    sel._wiredChange = true;
  }
}


function loadCategoriesForClientAfterNotes() {
  // Ensure the select exists (it's okay if the section is hidden at first)
  var sel = document.getElementById('categorySelect');
  if (!sel) {
    console.warn('loadCategoriesForClientAfterNotes: #categorySelect not found in DOM yet.');
    return;
  }

  if (!(window.google && google.script && google.script.run)) {
    console.error('google.script.run is not available yet.');
    return;
  }

  google.script.run
    .withSuccessHandler(function (cats) {
      // Populate the dropdown, but DO NOT unhide the section here.
      // Visibility is controlled strictly by showClientNotes() when a client is loaded.
      populateCategoryDropdown(Array.isArray(cats) ? cats : []);
      // Intentionally do NOT do:
      //   document.getElementById('categoryChangeSection').style.display = 'block';
    })
    .withFailureHandler(function (err) {
      console.error('Failed to load categories:', err);
    })
    .getUniqueCategories();
}


function updateCategorySelectValue(currentCategory) {
  var sel = document.getElementById('categorySelect');
  if (!sel) return;

  if (currentCategory) {
    // If the current category isn't yet in the dropdown (e.g., just created),
    // temporarily insert it before the sentinel so it's selectable.
    var exists = Array.from(sel.options)
      .some(function (o) { return o.value.toLowerCase() === String(currentCategory).toLowerCase(); });

    if (!exists) {
      var opt = document.createElement('option');
      opt.value = currentCategory;
      opt.textContent = currentCategory;
      var sentinel = sel.querySelector('option[value="__NEW__"]');
      sel.add(opt, sentinel); // insert before NEW CATEGORY…
    }
  }
  sel.value = currentCategory || '';
}

       // Helper function to create a regex pattern for different date formats
function createDatePattern(date) {
    let day = ('0' + date.getDate()).slice(-2);
    let month = ('0' + (date.getMonth() + 1)).slice(-2);
    let year2d = date.getFullYear().toString().substr(-2);
    let year4d = date.getFullYear().toString();

    // Patterns for different date formats
    let patterns = [
        `${month}/${day}/${year2d}`, // MM/DD/YY
        `${month}/${day}/${year4d}`, // MM/DD/YYYY
        `${parseInt(month)}/${day}/${year2d}`, // M/DD/YY
        `${parseInt(month)}/${day}/${year4d}`, // M/DD/YYYY
        `${month}/${parseInt(day)}/${year2d}`, // MM/D/YY
        `${month}/${parseInt(day)}/${year4d}`, // MM/D/YYYY
        `${parseInt(month)}/${parseInt(day)}/${year2d}`, // M/D/YY
        `${parseInt(month)}/${parseInt(day)}/${year4d}`  // M/D/YYYY
    ];

    // Combine into a single regex pattern
    return new RegExp(patterns.join('|'), 'g');
}
// Global variable to track the visibility state
var notesExpanded = false;


/***************************************
PASTE THIS ENTIRE BLOCK
***************************************/
/***************************************
REPLACE ENTIRE toggleNotesVisibility FUNCTION WITH THIS
***************************************/
/***************************************
REPLACE ENTIRE toggleNotesVisibility FUNCTION WITH THIS
***************************************/
function toggleNotesVisibility() {
  // Capture previous state to detect a click on the "LESS" button
  var wasExpanded = !!notesExpanded;

  // Flip the global boolean
  notesExpanded = !notesExpanded;

  // Only toggle within the UNHIGHLIGHTED section
  var container = document.getElementById('unhighlightedNotes');
  if (!container) return;

  var olderNotes = container.querySelectorAll('.older-note');
  olderNotes.forEach(function(line) {
    line.style.display = notesExpanded ? 'block' : 'none';
  });

  var toggleButton = document.getElementById('toggleNotesButton');
  if (toggleButton) {
    // If expanded now, the button should read LESS; if collapsed, MORE
    toggleButton.innerText = notesExpanded ? 'LESS' : 'MORE';
  }

  // If the user just clicked the LESS button (i.e., was expanded → now collapsed),
  // scroll to the top.
  if (wasExpanded && !notesExpanded) {
    // Use the global helper (defined below). If you have your own scrollToTop already, this will call it.
    scrollToTop();
  }
}
/***************************************
END REPLACEMENT
***************************************/


/***************************************
END OF PASTE
***************************************/
<!-- Example of where to paste in your .html or .gs file -->



// === GROUP & NORMALIZE NOTE LINES INTO DATED BLOCKS ===
// Each block has { date: Date|null, lines: string[] }.
// - A line with a date starts a new block.
// - Undated lines "inherit" the most recent block's date.
// - 2+ blank lines are collapsed to a single "" entry (one visual <br>).
function groupLinesIntoBlocks(allLines) {
  const blocks = [];
  let current = null;
  let pendingBlank = false;

  function pushCurrent() {
    if (current && current.lines.length) blocks.push(current);
    current = null;
    pendingBlank = false;
  }

  for (let raw of allLines) {
    const line = String(raw || "").replace(/\s+$/, ""); // trim right side; keep left spaces if user typed them
    const hasDate = !!extractDateFromLine(line);

    if (hasDate) {
      // New dated block
      pushCurrent();
      current = { date: extractDateFromLine(line), lines: [line] };
      pendingBlank = false;
      continue;
    }

    // Undated line
    // If no current block, start a null-date bucket (goes last after sort).
    if (!current) current = { date: null, lines: [] };

    if (line.trim() === "") {
      // Collapse 2+ blanks → single ""
      if (!pendingBlank) {
        current.lines.push(""); // represents a single <br>
        pendingBlank = true;
      }
    } else {
      current.lines.push(line);
      pendingBlank = false;
    }
  }

  pushCurrent();

  // Sort: dated blocks by ascending date; null-date blocks last.
  blocks.sort(function(a, b) {
    const ta = a.date ? a.date.getTime() : Infinity;
    const tb = b.date ? b.date.getTime() : Infinity;
    return ta - tb;
  });

  return blocks;
}

// Render a block's lines into safe HTML with single <br> for "" entries.
// Uses your existing formatNoteHTML() so names/date-bolding still apply.
function renderBlockHTML(block) {
  const parts = [];
  for (let i = 0; i < block.lines.length; i++) {
    const line = block.lines[i];
    if (line === "") {
      parts.push("<br>"); // collapsed blank
    } else {
      parts.push(formatNoteHTML(line));
    }
  }
  return parts.join("");
}

// Extract a Date from a line like M/D/YY, MM/DD/YYYY, etc.
// Returns Date or null if none found.
function extractDateFromLine(line) {
  var m = (line || '').match(/\b(\d{1,2})\/(\d{1,2})\/(\d{2,4})\b/);
  if (!m) return null;
  var month = parseInt(m[1], 10);
  var day   = parseInt(m[2], 10);
  var year  = parseInt(m[3], 10);
  if (year < 100) year = 2000 + year; // 24 → 2024
  // Basic sanity
  if (month < 1 || month > 12 || day < 1 || day > 31) return null;
  return new Date(year, month - 1, day);
}





function displayNotes(notes) {
  var notesDisplay = document.getElementById('notesDisplay');
  notesDisplay.innerHTML = '';

  if (!notes || notes.length === 0) {
    notesDisplay.innerHTML = '<p>No notes to display.</p>';
    return;
  }

  // Collect lines from Column C only (ignore Column E)
  var allLines = [];
  notes.forEach(function(n) {
    if (n.note && n.note !== 'N/A') {
      n.note.split('\n').forEach(function(line) {
        // Keep all lines (including blank) — groupLinesIntoBlocks will collapse 2+ blanks.
        allLines.push(String(line || ""));
      });
    }
  });

  if (allLines.length === 0) {
    notesDisplay.innerHTML = '<p>No notes to display.</p>';
    return;
  }

  // Build dated blocks with inheritance + blank-line collapsing
  var blocks = groupLinesIntoBlocks(allLines);

  // Container
  var container = document.createElement('div');
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.alignItems = 'stretch';
  container.style.width = '100%';
  container.style.position = 'relative';

  // === UNHIGHLIGHTED (older blocks, hidden by default) ===
  var unhighlightedWrap = document.createElement('div');
  unhighlightedWrap.id = 'unhighlightedNotes';
  unhighlightedWrap.style.display = 'flex';
  unhighlightedWrap.style.flexDirection = 'column';
  unhighlightedWrap.style.gap = '5px';
  container.appendChild(unhighlightedWrap);

  // === BUTTON ROW (MORE/LESS + ✏️) ===
  var buttonRow = document.createElement('div');
  buttonRow.style.display = 'inline-flex';
  buttonRow.style.alignSelf = 'center';
  buttonRow.style.alignItems = 'center';
  buttonRow.style.margin = '6px 0';
  buttonRow.style.gap = '0';

  var toggleBtn = document.createElement('button');
  toggleBtn.id = 'toggleNotesButton';
  toggleBtn.onclick = toggleNotesVisibility;
  toggleBtn.style.fontSize = '0.66em';
  toggleBtn.innerText = 'MORE';

  var editBtn = document.createElement('button');
  editBtn.id = 'editNotesButton';
  editBtn.className = 'secondary-button inline-button';
  editBtn.title = 'Edit notes';
  editBtn.setAttribute('aria-label', 'Edit notes');
  editBtn.style.fontSize = '0.66em';
  editBtn.style.marginLeft = '6px';
  editBtn.innerHTML = '✏️';
  editBtn.onclick = function (e) {
    e.stopPropagation();
    // Flatten blocks back to the user's raw lines (join with \n)
    var flattened = [];
    blocks.forEach(function(b){
      b.lines.forEach(function(line){
        // Turn the collapsed "" back into a blank line on edit
        flattened.push(line === "" ? "" : line);
      });
    });
    editCombinedNotes(container, flattened.join('\n'));
  };

  buttonRow.appendChild(toggleBtn);
  buttonRow.appendChild(editBtn);
  container.appendChild(buttonRow);

  // === HIGHLIGHTED (newest 3 blocks) ===
  var highlightedWrap = document.createElement('div');
  highlightedWrap.id = 'highlightedNotes';
  highlightedWrap.style.display = 'flex';
  highlightedWrap.style.flexDirection = 'column';
  highlightedWrap.style.gap = '5px';
  container.appendChild(highlightedWrap);

  // Determine which blocks are "top 3" newest
  var lastIdx = blocks.length - 1;
  var highlightCount = Math.min(3, blocks.length);
  var firstHighlightIdx = lastIdx - (highlightCount - 1);

  // Render blocks: newest 3 highlighted, older hidden by default
  blocks.forEach(function(block, i) {
    var div = document.createElement('div');
    div.style.fontSize = '32px';
    div.style.marginBottom = '0px';
    div.classList.add('note-line');

    // Render whole block as one "note" (date + its continuation lines)
    div.innerHTML = renderBlockHTML(block);

    if (i >= firstHighlightIdx) {
      // Newest 3 blocks → highlighted
      div.classList.add('latest-note');
      div.style.backgroundColor = 'yellow';
      highlightedWrap.appendChild(div);

      // CHIP only on the newest block (the very last one)
      if (i === lastIdx) {
        var chipInfo = window.__chipForCurrentClient || { initials: "", date: "" };
        var chipEl = createChipElement(
          document.getElementById('clientSelect').value || "",
          (chipInfo.initials || "").toUpperCase(),
          chipInfo.date || ""
        );
        div.appendChild(chipEl);
      }

    } else {
      // Older blocks → hidden by default; toggled by MORE/LESS
      div.classList.add('older-note');
      div.style.display = 'none';
      unhighlightedWrap.appendChild(div);
    }
  });

// Always show the row; only hide the MORE/LESS button if no older blocks
var hasOlder = unhighlightedWrap.children.length > 0;
toggleBtn.style.display = hasOlder ? 'inline-block' : 'none';
buttonRow.style.display = 'inline-flex'; // keep the row visible so ✏️ stays


  notesDisplay.appendChild(container);

  // Mentions hover/click handlers on both areas
  attachMentionHandlers(highlightedWrap);
  attachMentionHandlers(unhighlightedWrap);
}






  /* ===== UI STATE (client + filter) — ADD THIS BLOCK ONCE ===== */
const UI_STATE_KEY = 'uiState.v1';

function getCurrentUIState() {
  const dd = document.getElementById('topClientsFilterDropdown');
  const sel = document.getElementById('clientSelect');
  return {
    filter: dd ? dd.value : '',
    client: sel ? sel.value : ''
  };
}

function saveUIState(state) {
  try {
    localStorage.setItem(UI_STATE_KEY, JSON.stringify(state || getCurrentUIState()));
  } catch (_) {}
}

function restoreUIState() {
  // Always start in JB on a fresh load
  const dd = document.getElementById('topClientsFilterDropdown');
  if (dd) {
    dd.value = 'JB';
    if (typeof handleTopClientsFilterChange === 'function') {
      handleTopClientsFilterChange('JB');
    }
  }

  // Optionally restore the last open client (but keep JB filter)
  let raw = null, st = null;
  try { raw = localStorage.getItem(UI_STATE_KEY); } catch (_){}
  if (!raw) return;

  try { st = JSON.parse(raw) || {}; } catch (_){ st = {}; }

  if (st.client) {
    const sel = document.getElementById('clientSelect');
    if (sel) {
      sel.value = st.client;
      const clientAutocomplete = document.getElementById('clientAutocomplete');
      if (clientAutocomplete && sel.selectedIndex >= 0) {
        clientAutocomplete.value = sel.options[sel.selectedIndex].text;
      }
      if (typeof showClientNotes === 'function') showClientNotes();
    }
  }
}



/* Call this whenever you want a hard reload that returns to the same spot */
function reloadPreservingState() {
  saveUIState();   // snapshot current filter/client
  location.reload();
}
/* ===== END UI STATE BLOCK ===== */


// REPLACE EVERYTHING in editCombinedNotes(...) with this version
function editCombinedNotes(contentElement, existingText) {
  // Create a textarea with the existing text (all Column C lines)
  var textarea = document.createElement('textarea');
  textarea.value = existingText;
  textarea.style.width = '100%';
  textarea.style.boxSizing = 'border-box';
  textarea.style.resize = 'vertical';

  // === Mirror the client notes font exactly ===
  // Try to read computed styles from a rendered .note-line (the same look as client notes).
  (function syncToNoteFont() {
    // Prefer the newest highlighted note first, then any note-line
    var sample = document.querySelector('#highlightedNotes .note-line') ||
                 document.querySelector('.note-line');

    if (sample) {
      var cs = window.getComputedStyle(sample);
      textarea.style.fontFamily = cs.fontFamily || 'inherit';
      textarea.style.fontSize   = cs.fontSize   || '32px';
      textarea.style.lineHeight = cs.lineHeight || '1.3';
      textarea.style.fontWeight = cs.fontWeight || 'normal';
      textarea.style.letterSpacing = cs.letterSpacing || 'normal';
    } else {
      // Fallback if notes aren’t rendered yet
      textarea.style.fontFamily = 'inherit';
      textarea.style.fontSize   = '32px';
      textarea.style.lineHeight = '1.3';
    }
  })();

  // Replace the contentElement with the textarea
  var parent = contentElement.parentNode;
  parent.replaceChild(textarea, contentElement);

  // Ensure proper height
  setTimeout(function(){ adjustTextareaHeight(textarea); }, 0);
  textarea.addEventListener('input', function(){ adjustTextareaHeight(this); });

  textarea.addEventListener('blur', function() {
    var newText = textarea.value;
    if (newText !== existingText) {
      if (confirm('Save changes to NOTES (Column C)?')) {
        var clientName = document.getElementById('clientSelect').value;
        showLoadingBar();
        google.script.run
          .withSuccessHandler(function() {
            hideLoadingBar();
            alert('Notes updated successfully.');
            // Refresh the client view + top clients
            showClientNotes();
            displayTopClients();
            // Optionally send an edit summary (Column C)
            google.script.run.sendEditSummaryEmail(clientName, 'pastWork', existingText, newText);
          })
          .withFailureHandler(function(error) {
            hideLoadingBar();
            alert('Error saving edits: ' + error.message);
            // Rebuild the UI (without changes)
            showClientNotes();
          })
          .updateNotes(clientName, 'pastWork', newText); // <-- COLUMN C ONLY
      } else {
        // Rebuild the UI (no changes)
        showClientNotes();
      }
    } else {
      // No changes; rebuild
      showClientNotes();
    }
  });

  textarea.focus();
  textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
}


function adjustTextareaHeight(textarea) {
    textarea.style.height = 'auto'; // Reset height
    textarea.style.height = textarea.scrollHeight + 'px'; // Set new height
}

/**
 * highlightLatestDate(lines, element, style, chipInfo)
 * - lines: array of strings (each line of FOLLOW UPS or PAST)
 * - element: container to append into
 * - style: inline style string
 * - chipInfo (optional): { clientName, initials, chipDate, enableChip }
 *   Only when enableChip === true do we inject the chip (FOLLOW UPS only).
 */
function highlightLatestDate(lines, element, style, chipInfo) {
  var latestDate = null;
  var latestLine = null;

  lines.forEach(function(line) {
    var lineElement = document.createElement('div');
    lineElement.style = style;
    lineElement.innerHTML = line;
    var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);

    if (dates) {
      var date = new Date(dates[0]);
      if (!latestDate || date > latestDate) {
        latestDate = date;
        latestLine = lineElement;
      }
    }
    lineElement.classList.add('non-highlighted-note');
    element.appendChild(lineElement);
  });

  if (latestLine) {
    latestLine.style.backgroundColor = 'yellow';
    latestLine.classList.remove('non-highlighted-note');

    // If this is FOLLOW UPS, append the chip INSIDE the yellow highlight
    if (chipInfo && chipInfo.enableChip) {
      var initials = chipInfo.initials || '';
      var mmddyy   = chipInfo.chipDate || '';
      var clientName = chipInfo.clientName || (typeof currentClientName !== 'undefined' ? currentClientName : '');

      // create and insert chip after the text
      var chipEl = createChipElement(clientName, initials, mmddyy);
      latestLine.appendChild(chipEl);
    }
  }
}



function normalizeChipDate(raw) {
  if (!raw) return '';
  raw = String(raw).trim();
  let m, d, y;

  const m1 = raw.match(/^(\d{1,4})[-\/](\d{1,2})[-\/](\d{1,4})$/);
  if (m1) {
    const a = parseInt(m1[1], 10);
    const b = parseInt(m1[2], 10);
    const c = parseInt(m1[3], 10);
    if (String(m1[1]).length === 4) { // YYYY-MM-DD
      y = a; m = b; d = c;
    } else {                          // MM/DD/YY(YY)
      m = a; d = b; y = c;
    }
  } else {
    const dt = new Date(raw);
    if (isNaN(dt)) return raw;
    m = dt.getMonth() + 1;
    d = dt.getDate();
    y = dt.getFullYear();
  }
  if (y < 100) y = 2000 + y; // 24 -> 2024
  const yy = String(y).slice(-2);
  return `${m}/${d}/${yy}`;   // M/D/YY (no leading zeros)
}

function showCalendarInput() {
    var calendarSection = document.getElementById('calendarInputSection');
    if (calendarSection.style.display === 'none' || calendarSection.style.display === '') {
        calendarSection.style.display = 'block';
    } else {
        calendarSection.style.display = 'none';
    }
}

function submitPastWork() {
    var clientName = document.getElementById('clientSelect').value;
    var pastWorkContent = document.getElementById('newPastWork').value;

    // Show the loading bar
    showLoadingBar();

    // Update past work on the server
    google.script.run.withSuccessHandler(function(wasUpdated) {
        if (wasUpdated) {
showStarAnimation(); // SNIPPET #3


            alert('Past work updated successfully.');

             // Refresh the Top Clients list
            displayTopClients(); // Add this line

            // Fetch the updated client data
            google.script.run.withSuccessHandler(function(clients) {
                // Update your clients data and re-display the top clients
                showTopClients(clients);
            }).getTopClients();

            // Optionally, refresh the notes for the selected client
            showClientNotes();

            // Send an email notification if needed
            google.script.run.sendEmailNotification(clientName, pastWorkContent);
        } else {
            alert('Failed to update past work. Please try again.');
        }
        document.getElementById('newPastWork').value = ''; // Clear the textarea

        // Hide the loading bar after processing is complete
        hideLoadingBar();
    }).updatePastWork(clientName, pastWorkContent);
}





// Function to add the event to the calendar
function addEventToCalendar(clientName, futureWorkDate, futureWorkContent) {
    // Adjust this function call to match your existing addEventToCalendar logic
    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
    }).addEventToCalendar(clientName, futureWorkDate, futureWorkContent);
}






   // Modified updateCategory function
function updateCategory() {
    var clientName = document.getElementById('clientSelect').value;
    var newCategory = document.getElementById('categorySelect').value;

    // Clear the client notes display area
    document.getElementById('notesDisplay').innerHTML = '';
    document.getElementById('notesDisplay').style.display = 'none';

    showLoadingBar(); // Show the loading bar

    google.script.run.withSuccessHandler(function(updated) {
        hideLoadingBar(); // Hide the loading bar
        if (updated) {
            alert('Category updated successfully.');
            refreshUIWithNewCategory(clientName, newCategory); // Refresh UI with new category
            displayTopClients(); // Refresh the top clients list
        } else {
            alert('Failed to update category. Please try again.');
        }
    }).updateCategory(clientName, newCategory);
}

// Re-apply the current dropdown filter after any category change/save
function retriggerTopClientsFilter(){
  var dd = document.getElementById('topClientsFilterDropdown');
  var current = (dd && dd.value) ? dd.value : 'JB';
  if (typeof handleTopClientsFilterChange === 'function') {
    handleTopClientsFilterChange(current);
  } else if (typeof syncClientsListToDropdown === 'function') {
    // Fallback: full sync
    syncClientsListToDropdown();
  }
}



// Refresh UI with new category
function refreshUIWithNewCategory(clientName, newCategory) {
    // Call server-side function to get updated client list
    google.script.run.withSuccessHandler(function(clients) {
        clientsData = clients; // Update clientsData
        populateClientDropdown(clients); // Update the client dropdown
        selectUpdatedClient(clientName, newCategory); // Select the updated client
        displayTopClients(); // Refresh the top clients list
    }).getAllClientsData(); 
}


// Select the updated client in the dropdown and reload notes
function selectUpdatedClient(clientName, newCategory) {
    var clientSelect = document.getElementById('clientSelect');
    var clientAutocomplete = document.getElementById('clientAutocomplete');
    var updatedClientText = clientName + ' (' + newCategory + ')';

    // Set the clientSelect value to the clientName
    clientSelect.value = clientName;

    // Update the clientAutocomplete value to include the new category
    clientAutocomplete.value = updatedClientText;

    // Reload the notes for the selected client
    showClientNotes();
}


// Rest of your existing functions...


function displayTimeSensitiveTasks() {
    var tasksDisplay = document.getElementById('timeSensitiveTasksDisplay');
    // Check if the display area is already populated
    if (tasksDisplay.innerHTML.trim() !== '') {
        tasksDisplay.innerHTML = ''; // Clear the display area
    } else {
        showLoadingBar(); // Show the loading bar
        google.script.run.withSuccessHandler(function(result) {
            showTimeSensitiveTasks(result);
            hideLoadingBar(); // Hide the loading bar after loading is complete
        }).getTimeSensitiveTasks();
    }
}


function showTimeSensitiveTasks(tasks) {
    var tasksDisplay = document.getElementById('timeSensitiveTasksDisplay');
    tasksDisplay.innerHTML = ''; // Clear the existing content

    var clientsTasks = {}; // Object to hold the latest task per client and category

    tasks.forEach(function(task) {
        var parts = task.split('-');
        if (parts.length > 1) {
            var clientName = parts[0].trim();
            var clientCategory = parts[1].trim();
            var details = parts.slice(2).join('-').trim();
            var dateMatches = details.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
            if (dateMatches) {
                var date = new Date(dateMatches[0]);
                if (!clientsTasks[clientName]) {
                    clientsTasks[clientName] = {};
                }
                if (!clientsTasks[clientName][clientCategory] || clientsTasks[clientName][clientCategory].date < date) {
                    clientsTasks[clientName][clientCategory] = { date: date, details: details };
                }
            }
        }
    });

    // Now, create DOM elements for each client and their latest task per category
    for (var clientName in clientsTasks) {
        for (var category in clientsTasks[clientName]) {
            var taskInfo = clientsTasks[clientName][category];

            var clientDiv = document.createElement('div');
            var selectButton = document.createElement('button');
            selectButton.onclick = function() { selectClientFromTimeSensitiveTasks(clientName); };
            selectButton.textContent = clientName;
            clientDiv.appendChild(selectButton);

            var categorySpan = document.createElement('span');
            categorySpan.style.cssText = "margin-left: 10px;";
            categorySpan.textContent = category + ': ' + taskInfo.details;
            clientDiv.appendChild(categorySpan);

            tasksDisplay.appendChild(clientDiv);
            tasksDisplay.appendChild(document.createElement('hr')); // For visual separation
        }
    }
}




// Function to extract the base name of a client
function extractBaseName(clientName) {
    // Use a regex to remove trailing numbers and spaces
    return clientName.replace(/\d+$/, '').trim();
}







        // Submit New Client
      function submitNewClient() {
  var clientName = document.getElementById('newClientName').value;
  var futureWorkNote = document.getElementById('newClientNote').value; // Optional field
  var category = document.getElementById('newClientCategory').value;
  var pastWork = document.getElementById('pastWork').value; // Optional field

  // Check if the required fields (clientName and category) are filled
  if (!clientName || !category) {
    alert('Please fill in the required fields: Client Name and Category.');
    return;
  }

  // Call Google Apps Script function
  google.script.run
    .withSuccessHandler(function(response) {
      alert('New client added: ' + clientName); // Notify success
      // Clear input fields and hide form
      document.getElementById('newClientName').value = '';
      document.getElementById('newClientNote').value = '';
      document.getElementById('newClientCategory').value = '';
      document.getElementById('pastWork').value = '';
      document.getElementById('newClientForm').style.display = 'none';

      // Refresh clientsData and the dropdown
      google.script.run
        .withSuccessHandler(function(data){
          clientsData = data;
          populateClientDropdown(clientsData);

          // Now select the new client in the dropdown
          var clientSelect = document.getElementById('clientSelect');
          var clientAutocomplete = document.getElementById('clientAutocomplete');

          for (var i = 0; i < clientSelect.options.length; i++) {
            if (clientSelect.options[i].value === clientName) {
              clientSelect.selectedIndex = i;
              clientAutocomplete.value = clientSelect.options[i].text;
              break;
            }
          }
          // Now call showClientNotes()
          showClientNotes();

          console.log('Before alert');
          // Show the pop-up message
          alert('PLEASE ADD FUTURE WORK IN ORDER FOR NEW CLIENT TO ENTER DASHBOARD WORKFLOW');
          console.log('After alert');

        })
        .withFailureHandler(function(error) {
          console.error('Error fetching client data:', error);
          alert('Error fetching client data. Please try again.');
        })
        .getAllClientsData();

    })
    .withFailureHandler(function(error) {
      console.error('Error adding new client:', error);
      alert('Error adding new client. Please try again.');
    })
    .addNewClientWithPastWork(clientName, futureWorkNote, category, pastWork);
}







// Function triggered by the "TOP PRIORITY CLIENTS" button
function displayTopClients() {
  displayFilteredClients('JB'); // Show strictPast (Immediate) clients by default
}

// This function is triggered by the quadrant buttons
function displayFilteredClients(filter) {
    showLoadingBar(); // Show loading indication
    google.script.run.withSuccessHandler(function(result) {
        showTopClients(result, filter);
        hideLoadingBar(); // Hide loading indication

        // Get today's date in the required format
        var today = new Date();
        var options = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
        var formattedDate = today.toLocaleDateString('en-US', options).toUpperCase();

        // Initialize titles
        var dateTitle = '';
        var topClientsTitle = '';

        // Set titles based on the filter
      // SNIPPET: ALWAYS SHOW DATE
// Set topClientsTitle based on the filter, but ALWAYS set dateTitle to today's date
dateTitle = formattedDate; 
switch (filter) {
    case 'strictPast':
        topClientsTitle = 'TOP CLIENTS:';
        break;
    case 'flexiblePast':
        topClientsTitle = 'FLEXIBLE';
        break;
    case 'strictUpcoming':
        topClientsTitle = 'STRICT';
        break;
    case 'flexibleUpcoming':
        topClientsTitle = 'FLEXIBLE';
        break;
    case 'others':
        topClientsTitle = 'OTHERS';
        break;
    case 'all':
        topClientsTitle = 'ALL';
        break;
    default:
        topClientsTitle = filter.toUpperCase();
        break;
}

// Now that dateTitle is set for EVERY filter...
document.getElementById('dateTitle').innerText = dateTitle;
document.getElementById('topClientsTitle').innerText = '';
document.getElementById('topClientsTitle').style.display = 'none';

    }).getTopClients(); // Your server-side function to fetch top clients
}

/**********************************************
  (A) The "OLD" function (for updates/reloading)
**********************************************/
function showTopClients(clients, filter = 'all') {
    var clientsDisplay = document.getElementById('topClientsDisplay');
    clientsDisplay.innerHTML = ''; // Clear the display area

    var now = new Date();
    var fiftyHoursFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now

    // Calculate today's day of the week index (0 for Sun, 1 for Mon, etc.)
    var todayIndex = new Date().getDay();
    var daysOfWeek = ['Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'];
    var todayDay = daysOfWeek[todayIndex];
    // Create a new array starting from today's day
    var sortedDays = daysOfWeek.slice(todayIndex).concat(daysOfWeek.slice(0, todayIndex));

    // Filter clients based on the filter parameter
    var filteredClients = clients.filter(function(client) {
        var latestDate = null;
        client.followUps.forEach(function(followUp) {
            var followUpLines = followUp.split('\n');
            followUpLines.forEach(function(line) {
                var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
                if (dates) {
                    var date = new Date(dates[0]);
                    if (!latestDate || date > latestDate) {
                        latestDate = date;
                    }
                }
            });
        });
        client.latestDate = latestDate; // Store the latestDate in client for sorting

        if (filter === 'all') {
            return true;
        } else {
            switch (filter) {
                case 'strictUpcoming':
                    return client.columnB === "STRICT" && latestDate && latestDate > fiftyHoursFromNow;
                case 'strictPast':
                    return client.columnB === "STRICT" && latestDate && latestDate <= fiftyHoursFromNow;
                case 'flexibleUpcoming':
                    return client.columnB === "FLEXIBLE" && latestDate && latestDate > fiftyHoursFromNow;
                case 'flexiblePast':
                    return client.columnB === "FLEXIBLE" && latestDate && latestDate <= fiftyHoursFromNow;
                default:
                    return !((client.columnB === "STRICT" || client.columnB === "FLEXIBLE") &&
                             latestDate &&
                            (latestDate > fiftyHoursFromNow || latestDate <= fiftyHoursFromNow));
            }
        }
    });

// === SORT BY CHIP DATE (earliest on top). Blanks/invalids go last.
// Secondary tie-breakers: day-of-week order from today, then name.
// === SORT BY CHIP DATE (blanks first, then earliest date) ===
filteredClients.sort(function(a, b) {
    var ta = chipDateToTime(a && a.chipDate);
    var tb = chipDateToTime(b && b.chipDate);

    // Primary sort: blanks first, then earliest valid date
    if (ta !== tb) return ta - tb;

    // Secondary sort: day of week starting from today
    var ia = sortedDays.indexOf(a.columnD);
    var ib = sortedDays.indexOf(b.columnD);
    ia = ia === -1 ? Infinity : ia;
    ib = ib === -1 ? Infinity : ib;
    if (ia !== ib) return ia - ib;

    // Final tie-breaker: alphabetical by name
    var na = (a.name || '').toLowerCase();
    var nb = (b.name || '').toLowerCase();
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
});



    if (filter === 'strictPast') {
        var clientsMatchingToday = [];
        var otherClients = [];

        filteredClients.forEach(function(client) {
            if (client.columnD === todayDay) {
                clientsMatchingToday.push(client);
            } else {
                otherClients.push(client);
            }
        });

        // Display clients scheduled for today
        clientsMatchingToday.forEach(function(client) {
            displayClient(client, clientsDisplay);
        });

        // If there are other clients, add the toggle button
    // If there are other clients, just display them directly (no button)
if (otherClients.length > 0) {
    otherClients.forEach(function(client) {
        displayClient(client, clientsDisplay);
    });
}


    } else {
        // For other filters, display all filtered clients as before
        filteredClients.forEach(function(client) {
            displayClient(client, clientsDisplay);
        });
    }
/* PASTE #2A — call wiring after Top Clients repaint */
wireToplistSuggestionTextareas();
if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();

}

/**********************************************
  (B) The "NEW" function (for initial page load)
**********************************************/
function showTopClientsOnLoad(clients, filter = 'JB') {
    // SNIPPET: Always set today's date & "TOP CLIENTS" label on page load
    var today = new Date();
    var options = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
    var formattedDate = today.toLocaleDateString('en-US', options).toUpperCase();

    // Put the current date text into the #dateTitle div:
    document.getElementById('dateTitle').innerText = formattedDate;

(function clearInitialTitle(){
  var titleEl = document.getElementById('topClientsTitle');
  if (!titleEl) return;
  titleEl.innerText = '';
  titleEl.style.display = 'none';
})();


    var clientsDisplay = document.getElementById('topClientsDisplay');
    clientsDisplay.innerHTML = ''; // Clear the display area

    var now = new Date();
    // Name is historical; actually 7 days
    var fiftyHoursFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now

    // Calculate today's day of the week index (0 for Sun, 1 for Mon, etc.)
    var todayIndex = new Date().getDay();
    var daysOfWeek = ['Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'];
    var todayDay = daysOfWeek[todayIndex];

    // Create a new array starting from today's day
    var sortedDays = daysOfWeek.slice(todayIndex).concat(daysOfWeek.slice(0, todayIndex));

    // Filter clients based on the filter parameter
    var filteredClients = clients.filter(function(client) {
        var latestDate = null;
        client.followUps.forEach(function(followUp) {
            var followUpLines = followUp.split('\n');
            followUpLines.forEach(function(line) {
                var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
                if (dates) {
                    var date = new Date(dates[0]);
                    if (!latestDate || date > latestDate) {
                        latestDate = date;
                    }
                }
            });
        });
        client.latestDate = latestDate; // Store the latestDate in client for sorting

        if (filter === 'all') {
            return true;
        } else {
            switch (filter) {
                case 'strictUpcoming':
                    return client.columnB === "STRICT" && latestDate && latestDate > fiftyHoursFromNow;
                case 'strictPast':
                    return client.columnB === "STRICT" && latestDate && latestDate <= fiftyHoursFromNow;
                case 'flexibleUpcoming':
                    return client.columnB === "FLEXIBLE" && latestDate && latestDate > fiftyHoursFromNow;
                case 'flexiblePast':
                    return client.columnB === "FLEXIBLE" && latestDate && latestDate <= fiftyHoursFromNow;
                default:
                    return !((client.columnB === "STRICT" || client.columnB === "FLEXIBLE") &&
                             latestDate &&
                             (latestDate > fiftyHoursFromNow || latestDate <= fiftyHoursFromNow));
            }
        }
    });

    // Sort the clients by latestDate in ascending order
    filteredClients.sort(function(a, b) {
        var dateA = a.latestDate ? a.latestDate.getTime() : 0;
        var dateB = b.latestDate ? b.latestDate.getTime() : 0;
        return dateA - dateB;
    });

    // Sort the clients by day of the week starting from today
    filteredClients.sort(function(a, b) {
        var indexA = sortedDays.indexOf(a.columnD);
        var indexB = sortedDays.indexOf(b.columnD);
        indexA = indexA === -1 ? Infinity : indexA; // If day is not found, place it at the end
        indexB = indexB === -1 ? Infinity : indexB; // If day is not found, place it at the end
        return indexA - indexB;
    });

    if (filter === 'strictPast') {
        var clientsMatchingToday = [];
        var otherClients = [];

        filteredClients.forEach(function(client) {
            if (client.columnD === todayDay) {
                clientsMatchingToday.push(client);
            } else {
                otherClients.push(client);
            }
        });

        // Display clients scheduled for today
        clientsMatchingToday.forEach(function(client) {
            displayClient(client, clientsDisplay);
        });

        // Display ALL other clients directly — NO BUTTON
        otherClients.forEach(function(client) {
            displayClient(client, clientsDisplay);
        });

    } else {
        // For other filters, display all filtered clients as before
        filteredClients.forEach(function(client) {
            displayClient(client, clientsDisplay);
        });
    }
    /* PASTE #2B — call wiring after initial Top Clients paint */
wireToplistSuggestionTextareas();
if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();

}



function updateColumnB(clientName, columnBValue) {
    // Show the loading bar when the update process begins
    showLoadingBar();

    google.script.run
        .withSuccessHandler(function() {
            // Log success message or inform the user through the UI
            console.log('Column B updated successfully for', clientName, 'to', columnBValue);
            // Optionally, refresh client data on the page to reflect the update
            // e.g., getTopClients(); assuming you have a function to refresh the displayed clients

            // Hide the loading bar after successfully updating
            hideLoadingBar();
        })
        .withFailureHandler(function(error) {
            // Log error or inform the user through the UI
            console.error('Error updating Column B for', clientName, ':', error);

            // Hide the loading bar even if the update fails to inform the user that the process has completed
            hideLoadingBar();
        })
        .updateClientColumnB(clientName, columnBValue); // Assuming this is the correct server-side function name
}


function updateColumnD(clientName, columnDValue) {
    // Show the loading bar when the update process begins
    showLoadingBar();

    google.script.run
        .withSuccessHandler(function() {
            // Log success message or inform the user through the UI
            console.log('Column D updated successfully for', clientName, 'to', columnDValue);
            // Optionally, refresh client data on the page to reflect the update
            // e.g., getTopClients(); assuming you have a function to refresh the displayed clients

            // Hide the loading bar after successfully updating
            hideLoadingBar();
        })
        .withFailureHandler(function(error) {
            // Log error or inform the user through the UI
            console.error('Error updating Column D for', clientName, ':', error);

            // Hide the loading bar even if the update fails to inform the user that the process has completed
            hideLoadingBar();
        })
        .updateClientColumnD(clientName, columnDValue); // Assuming this is the correct server-side function name
}


// Ensure to define or include your existing functions like saveAllClientData, selectClientFromButton, showLoadingBar, hideLoadingBar, and others as needed.


//////////////////////////////////////////////


function toggleTopClientsDisplay() {
    var clientsDisplay = document.getElementById('topClientsDisplay');
    // Simply toggle the display visibility without refreshing the content
    if (clientsDisplay.style.display === 'block' || clientsDisplay.style.display === '') {
        clientsDisplay.style.display = 'none'; // Hide
    } else {
        clientsDisplay.style.display = 'block'; // Show without refreshing the data
    }
}



function saveAllClientData() {
    showLoadingBar(); // Optionally show a loading indicator

    var clientsDisplay = document.getElementById('topClientsDisplay');
    var clientDivs = clientsDisplay.querySelectorAll('div'); // Select all client divs

    var saveOperations = []; // To keep track of save operations

    for (var i = 0; i < clientDivs.length; i++) {
        var clientDiv = clientDivs[i];
        var clientName = clientDiv.querySelector('button.inline-button').innerText; // Assuming the client's name is in the button
        var textBox = clientDiv.querySelector('input[type="text"]');
        var newData = textBox.value;

        // Save each client's data
        (function(clientName, newData) {
            saveOperations.push(new Promise(function(resolve, reject) {
                google.script.run.withSuccessHandler(function() {
                    resolve(); // Resolve the promise when data is successfully saved
                }).withFailureHandler(function() {
                    reject(); // Reject the promise if there's an error
                }).updateClientData(clientName, newData);
            }));
        })(clientName, newData);
    }

    // Wait for all save operations to complete before refreshing
    Promise.all(saveOperations).then(function() {
        hideLoadingBar(); // Hide loading bar on success
        alert('All data saved successfully.'); // Notify the user
        displayTopClients(); // Refresh the display for top clients
    }).catch(function() {
        hideLoadingBar(); // Hide loading bar in case of error
        alert('An error occurred while saving the data.'); // Notify the user about the error
    });
}








// This function smoothly scrolls the window to the top
function scrollToTop() {
    window.scrollTo({
        top: 0,
        left: 0,
        behavior: 'smooth'
    });
}










function displayClientsByCategory() {
    var selectedCategory = document.getElementById('categoryDisplaySelect').value;
    if (selectedCategory) {
        google.script.run.withSuccessHandler(showClientsByCategory).getClientsByCategory(selectedCategory);
    }
}

function showClientsByCategory(clients) {
    var displayArea = document.getElementById('categoryClientsDisplay');
    displayArea.innerHTML = '';

    clients.forEach(function(client) {
        var clientInfo = `
            <div>
                <strong>Name:</strong> ${client.name}<br>
                <strong>Date:</strong> ${client.date}<br>
                <strong>Note:</strong> ${client.note}<br>
                <strong>Follow-up:</strong> ${client.followUp}<br>
                <strong>Category:</strong> ${client.category}<br>
            </div>
            <hr>
        `;
        displayArea.innerHTML += clientInfo;
    });
}

function showAppointmentInput() {
    var appointmentSection = document.getElementById('appointmentInputSection');
    if (appointmentSection.style.display === 'none' || appointmentSection.style.display === '') {
        appointmentSection.style.display = 'block';
    } else {
        appointmentSection.style.display = 'none';
    }
}

function submitAppointmentToCalendar() {
    var clientName = document.getElementById('clientSelect').value;
    var appointmentDate = document.getElementById('appointmentDate').value;
    var appointmentTime = document.getElementById('appointmentTime').value;

    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
        // Assuming 'refreshClientData' is a function to refresh client data
        refreshClientData(); // Call this function to refresh the client data
    }).addAppointmentToCalendar(clientName, appointmentDate, appointmentTime);
}

function refreshClientData() {
    var selectedClient = document.getElementById('clientSelect').value;
    if (selectedClient) {
        // Call the function that fetches and displays the client data
        showClientNotes();
    }
}




function resizeElements(applySmallerSize) {
    var buttons = tasksDisplay.querySelectorAll('button');
    buttons.forEach(function(button) {
        if (applySmallerSize) {
            button.classList.add('smaller-size');
        } else {
            button.classList.remove('smaller-size');
        }
    });
}











        // Show Add New Client Form
function displayAddNewClientForm() {
    var form = document.getElementById('newClientForm');
    if (form.style.display === 'block') {
        form.style.display = 'none'; // Hide the form if it's currently shown
    } else {
        form.style.display = 'block'; // Show the form if it's currently hidden
    }
}
var suggestions; // Keep this global to store suggestions

function autocompleteClient() {
  var clientSelect = document.getElementById('clientSelect');

    var inputElement = document.getElementById('clientAutocomplete');
    suggestions = document.getElementById('autocompleteSuggestions');
    if (!suggestions) {
        suggestions = document.createElement('div');
        suggestions.id = 'autocompleteSuggestions';
        inputElement.parentNode.appendChild(suggestions);
    }

    inputElement.addEventListener('input', function() {
        var inputValue = inputElement.value.toLowerCase();

        // Clear current suggestions
        suggestions.innerHTML = '';

        // Calculate the available height below the input field
        var rect = inputElement.getBoundingClientRect();
        var availableHeight = window.innerHeight - rect.bottom;

        // Set the max-height of suggestions to the available height
        suggestions.style.maxHeight = availableHeight + 'px';

        // Populate suggestions
        clientsData.forEach(function(client) {
            if (client.rowText.includes(inputValue) && inputValue) {
                var suggestion = document.createElement('div');
                suggestion.innerHTML = client.clientName + (client.category ? ' (' + client.category + ')' : '');

                suggestion.onclick = function() {
                    inputElement.value = this.innerHTML;
                    clientSelect.value = client.clientName;
                    showClientNotes();
                        scrollToTop(); // Add this line to scroll to the top

                    suggestions.innerHTML = ''; // Hide suggestions after selection
                };

                suggestions.appendChild(suggestion);
            }
        });
    });
}





function displayDomTasks() {
    var tasksDisplayArea = document.getElementById('domTasksDisplay');
    
    // Check if tasks are currently displayed
    if (tasksDisplayArea.innerHTML.trim() !== '') {
        // If displayed, clear the content to hide them
        tasksDisplayArea.innerHTML = '';
    } else {
        showLoadingBar(); // Show the loading bar
        google.script.run.withSuccessHandler(function(result) {
            showDomTasks(result);
            hideLoadingBar(); // Hide the loading bar after loading is complete
        }).getDomTasks();
    }
}




// Function to extract client name from the task string
function extractClientNameFromTask(taskString) {
    var endOfNameIndex = taskString.indexOf(' - '); // Find the index where client name ends
    if (endOfNameIndex !== -1) {
        return taskString.substring(0, endOfNameIndex).trim(); // Extract client name
    }
    return ''; // Return empty string if not found
}

// This function will be called when the task button is clicked
function selectClientFromButton(clientText) {

        hideClientNotes(); // Call the function when the input is clicked into


    var clientSelect = document.getElementById('clientSelect');

    for (var i = 0; i < clientSelect.options.length; i++) {
        // Extract the client name and category from the dropdown option
        var optionText = clientSelect.options[i].text;
        var optionClientName = optionText.split(' (')[0]; // Get the client name before the '('

        // Check if the client names match (without considering the category)
        if (clientText.startsWith(optionClientName)) {
            clientSelect.selectedIndex = i;
            showClientNotes(); // Refresh client notes if needed
            scrollToTop(); // Scroll to the top of the page
            break;
        }
    }
}

// 1) Paint function
function paintRecentBar(list){
  const wrap = document.getElementById('recentClientsBar');
  if (!wrap) return;
  if (!list || !list.length) { wrap.innerHTML = ''; return; }

  wrap.innerHTML = list.map(e => {
    const muted = e.columnL ? '' : ' rc-muted';
    const cat   = e.category ? `<span class="rc-cat">${e.category}</span>` : '';
    const chip  = (e.chipInitials || e.chipDate)
      ? `<span class="rc-chip">${(e.chipInitials||'').toUpperCase()}${e.chipDate?' · '+e.chipDate:''}</span>` : '';
    const dot   = e.columnL ? '<span class="rc-dot" title="Has In-Progress"></span>' : '';
    return `
      <div class="recent-pill${muted}" data-name="${e.name}" title="${e.name}">
        ${dot}
        <span class="rc-name">${e.name}</span>
        ${cat}
        ${chip}
      </div>`;
  }).join('');

  // click → open that client (use your existing loader)
  wrap.querySelectorAll('.recent-pill').forEach(pill => {
    pill.addEventListener('click', () => {
      const name = pill.getAttribute('data-name');
      // If you have a helper like selectClientFromButton(name), prefer that:
      if (typeof selectClientFromButton === 'function') {
        selectClientFromButton(name);
      } else {
        // Fallback to your existing dropdown flow
        const sel = document.getElementById('clientSelect');
        if (sel) {
          sel.value = name;
          showClientNotes();
          // keep the text box in sync if you use it
          const ca = document.getElementById('clientAutocomplete');
          if (ca) ca.value = name;
        }
      }
    });
  });
}

// 2) Load on page load: fast render, then (optional) metadata refresh
function loadRecentBar() {
  // Fast: use cached metadata
  google.script.run
    .withSuccessHandler(list => paintRecentBar(list))
    .getRecentClients(12, false);

  // Optional: refresh metadata in a second pass so chips/categories are up to date
  google.script.run
    .withSuccessHandler(list => paintRecentBar(list))
    .getRecentClients(12, true);
}

// Kick it off as soon as DOM is ready
document.addEventListener('DOMContentLoaded', loadRecentBar);

// 3) Whenever a client is opened, log it and refresh the bar
function onClientOpened(name){
  google.script.run
    .withSuccessHandler(() => loadRecentBar())
    .logRecentClient(name, 12);
}

// If you have a central place that runs when a client is selected, call onClientOpened there.
// Example: at the end of selectClientFromButton(...) or showClientNotes():
// onClientOpened(clientName);







// Utility function to format the date
function formatDate(dateString) {
  var dateParts = dateString.split('-'); // Split YYYY-MM-DD
  if (dateParts.length === 3) {
    var year = dateParts[0].substring(2); // Get last two digits of the year
    var month = dateParts[1];
    var day = dateParts[2];
    return month + '/' + day + '/' + year; // Format to MM/DD/YY
  }
  return dateString; // Return original string if it doesn't match expected format
}


function selectClientFromCalendarTask(clientName) {
    var clientSelect = document.getElementById('clientSelect');
    for (var i = 0; i < clientSelect.options.length; i++) {
        if (clientSelect.options[i].text.includes(clientName)) {
            clientSelect.selectedIndex = i;
            showClientNotes();
            scrollToTop(); // Smooth scroll to the top
            break;
        }
    }
}

// Smooth scroll to the top of the page
function scrollToTop() {
    window.scrollTo({
        top: 0,
        left: 0,
        behavior: 'smooth'
    });
}



function handleCalendarTaskSelection(taskName) {
    callServerFunction('getCategoryForClient', [taskName], function(category) {
        if (category) {
            selectClientFromCalendarTasks(taskName + ' (' + category + ')');
        } else {
            console.error('Category not found for client:', taskName);
            // Handle the case where the category is not found
        }
    });
}



function showLoadingBar() {
    var loadingBarContainer = document.getElementById('loadingBarContainer');
    var loadingBar = document.getElementById('loadingBar');
    loadingBarContainer.style.display = 'block';
    loadingBar.style.width = '0'; // Start with an empty bar
    setTimeout(function() {
        loadingBar.style.width = '100%'; // Transition to full width
    }, 20); // Start the transition slightly after displaying the bar
}

function hideLoadingBar() {
    var loadingBarContainer = document.getElementById('loadingBarContainer');
    var loadingBar = document.getElementById('loadingBar');
    loadingBar.style.width = '0'; // Reset to empty
    setTimeout(function() {
        loadingBarContainer.style.display = 'none';
    }, 2000); // Wait for the transition to finish before hiding the container
}



function handleUserSelectionChange() {
    var userSelection = document.getElementById('userSelection').value;
    var dateInputContainer = document.getElementById('dateInputContainer');

    // Show the date input for both 'JB' and 'Ricky'
    if (userSelection === 'JB' || userSelection === 'Ricky') {
        dateInputContainer.style.display = 'block';
    } else {
        dateInputContainer.style.display = 'none';
    }
}



function submitFutureWork() {
    var userSelection = document.getElementById('userSelection').value;
    var clientName = document.getElementById('clientSelect').value;
    var futureWorkText = document.getElementById('newFollowUp').value;
    var futureWorkDate = document.getElementById('futureWorkDate').value;

    // Show loading bar
    showLoadingBar();

    // Check if user is 'JB' or 'Ricky' and no date is entered
    if ((userSelection === 'JB' || userSelection === 'Ricky') && !futureWorkDate) {
        alert('Please enter a date for future work.');
        hideLoadingBar(); // Hide loading bar if validation fails
        return; // Stop execution of the function
    }

    // Call server-side function asynchronously
    google.script.run.withSuccessHandler(function(response) {
        alert('Future work added successfully to follow-up notes.');
        document.getElementById('newFollowUp').value = '';
        document.getElementById('futureWorkDate').value = '';


        // Refresh the Top Clients list
        displayTopClients(); // Add this line

        // Refresh client notes
        showClientNotes();

        // Send email notification
        google.script.run.sendEmailNotification(clientName, futureWorkText);

        // If JB is selected and date is provided, create a task in JB's calendar
        if (userSelection === 'JB' && futureWorkDate) {
            addEventToCalendar(clientName, futureWorkDate, futureWorkText);
        }

        // If Ricky is selected and date is provided, create a task in Ricky's calendar
        if (userSelection === 'Ricky' && futureWorkDate) {
            addEventToRickyCalendar(clientName, futureWorkDate, futureWorkText);
        }

        hideLoadingBar(); // Hide loading bar after successful execution
    }).withFailureHandler(function(error) {
        alert('Error updating follow-up note.');
        hideLoadingBar(); // Hide loading bar also in case of failure
    }).updateFollowUp(clientName, futureWorkText, futureWorkDate, userSelection);
}








// Rest of your functions remain unchanged


function createCalendarTask(futureWorkText, futureWorkDate) {
    // Your logic to create a task in the calendar goes here
    // This is a placeholder function - replace with your actual calendar task creation logic
    console.log("Creating calendar task for:", futureWorkText, "on", futureWorkDate);
}




// Function to add the event to the calendar
function addEventToCalendar(clientName, futureWorkDate, futureWorkContent) {
    // Adjust this function call to match your existing addEventToCalendar logic
    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
    }).addEventToCalendar(clientName, futureWorkDate, futureWorkContent);
}

function addEventToRickyCalendar(clientName, futureWorkDate, futureWorkContent) {
    // Adjust this function call to match your existing addEventToCalendar logic
    google.script.run.withSuccessHandler(function(response) {
        alert(response); // Display the returned message
    }).addEventToRickyCalendar(clientName, futureWorkDate, futureWorkContent);
}


function toggleDateInput() {
        var userSelection = document.getElementById('userSelection').value;
        var clientSelected = document.getElementById('clientSelect').value;
        var dateInputContainer = document.getElementById('dateInputContainer');

        // Check if a client is selected and user is "JB"
        if (clientSelected && userSelection === 'JB') {
            dateInputContainer.style.display = 'block';
        } else {
            dateInputContainer.style.display = 'none';
        }
    }


  google.charts.load('current', {'packages':['corechart']});
  google.charts.setOnLoadCallback(drawChart);
  
function drawChart() {
  google.script.run.withSuccessHandler(function(chartData) {
    var data = google.visualization.arrayToDataTable(chartData);

    // Set chart options
    var options = {
  width: 900,
  height: 500,
  chartArea: { width: '100%', height: '85%' }, // Adjust if necessary
  pieSliceText: 'none',
  legend: 'none',
  tooltip: { textStyle: { fontSize: 12 }, isHtml: true, trigger: 'focus' },
  titleTextStyle: {
    fontSize: 14, // Try reducing the font size
    color: '#333',
    bold: true,
    italic: false
  },
  // ... other options ...
};


    // Instantiate and draw the chart
    var chart = new google.visualization.PieChart(document.getElementById('piechart'));
    chart.draw(data, options);
  }).getClientCategoriesForPieChart();
}



function drawHeatmap(weekdayCounts) {
  // Define the correct order of weekdays, starting from Sunday or Monday
  var daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  // Convert weekdayCounts to an array and sort by the daysOrder
  var sortedData = daysOrder.map(day => {
    return [day, weekdayCounts[day] || 0]; // Fallback to 0 if no data for the day
  });

  // Now create the DataTable using the sorted data
  var data = new google.visualization.DataTable();
  data.addColumn('string', 'Weekday');
  data.addColumn('number', 'Past Notes');
  sortedData.forEach(function(row) {
    data.addRow(row);
  });

  // Define the chart options
  var options = {
    title: 'Client Interactions Per Weekday',
    hAxis: {title: 'Weekday'},
    vAxis: {title: 'Number of Interactions'}
  };

  // Draw the chart
  var chart = new google.visualization.ColumnChart(document.getElementById('heatmap'));
  chart.draw(data, options);
}

var futureChart = new google.visualization.ColumnChart(document.getElementById('futureHeatmap'));
futureChart.draw(futureData, options);

// Function to get data and draw the heatmap
function getAndDrawHeatmapData() {
    // Call server-side function to get data
    google.script.run.withSuccessHandler(drawHeatmap).getWeekdayCountsForHeatmap();
}

// Updated function to get data and draw the heatmap for future notes
function getAndDrawFutureHeatmapData() {
    // Call server-side function to get data for future notes
    google.script.run.withSuccessHandler(drawFutureHeatmap).getFutureWeekdayCountsForHeatmap();
}

function drawFutureHeatmap(weekdayCounts) {
  // Define the correct order of weekdays, starting from Sunday or Monday
  var daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  // Convert weekdayCounts for future notes to an array and sort by daysOrder
  var sortedData = daysOrder.map(day => {
    return [day, weekdayCounts[day] || 0]; // Fallback to 0 if no data for the day
  });

  // Create the DataTable using the sorted data
  var data = new google.visualization.DataTable();
  data.addColumn('string', 'Weekday');
  data.addColumn('number', 'Future Notes');
  sortedData.forEach(function(row) {
    data.addRow(row);
  });

  // Define the chart options for the future notes heatmap
  var options = {
    title: 'Future Client Interactions Per Weekday',
    hAxis: {title: 'Weekday'},
    vAxis: {title: 'Number of Future Notes'},
    colors: ['#1E90FF'], // Custom color for the bars, change as needed
    // Additional styling options can be added here
  };

  // Draw the chart in the 'futureHeatmap' div
  var chart = new google.visualization.ColumnChart(document.getElementById('futureHeatmap'));
  chart.draw(data, options);
}

function loadAllHeatmaps() {
    getAndDrawHeatmapData();
    getAndDrawFutureHeatmapData();
}


    function drawScatterPlot() {
        google.script.run.withSuccessHandler(function(chartData) {
            var data = google.visualization.arrayToDataTable(chartData);
            var options = {
    title: '', // Remove chart title
    hAxis: {
        title: 'Category',
        titleTextStyle: {
            fontSize: 0 // Font size for hAxis title
        }
    },
    vAxis: {
        title: 'Interactions',
        titleTextStyle: {
            fontSize: 0 // Font size for vAxis title
        }
    },
    legend: 'none'
};



            var chart = new google.visualization.ScatterChart(document.getElementById('scatter_chart_div'));
            chart.draw(data, options);
        }).getDataForScatterPlot();
    }


function displayTable() {
    google.script.run.withSuccessHandler(buildTable).generateTable();
  }

 function buildTable(data) {
    var values = data.values;
    var backgrounds = data.backgrounds;

    var rowHeight = '20px'; // You can adjust this value as needed
    var html = '<table style="border-collapse: collapse; width: auto; font-size: 9px; margin: 0 auto;">';

    for (var i = 0; i < values.length; i++) {
        html += `<tr style="height: ${rowHeight};">`;
        for (var j = 0; j < values[i].length; j++) {
            var cellValue = values[i][j];
            // Ensure cellValue is a string and check if it's numeric
            var isNumeric = /^-?\d+$/.test(cellValue.toString().trim());
            var formattedValue = cellValue;
            if (isNumeric) {
                // Format as dollar value without cents
                formattedValue = parseFloat(cellValue).toLocaleString('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                });
            }

            // Apply right-align for columns B and D
            var textAlignStyle = (j === 1 || j === 4) ? 'text-align: right;' : 'text-align: center;';

            // Make cell A1 bold
            var fontWeightStyle = (i === 0 && j === 0) ? 'font-weight: bold;' : '';

            html += '<td style="padding: 4px 6px; background-color:' + backgrounds[i][j] + 
                    '; line-height: normal; ' + textAlignStyle + fontWeightStyle + 
                    ' vertical-align: middle;">' + formattedValue + '</td>';
        }
        html += '</tr>';
    }

    html += '</table>';
    document.getElementById('tableContainer').innerHTML = html;
}















  window.onload = displayData;

function displayBirthdays() {
  var topClientsTitle = document.getElementById('topClientsTitle');
  var clientsDisplay = document.getElementById('topClientsDisplay');

  // Clear existing content
  clientsDisplay.innerHTML = '';
  topClientsTitle.innerHTML = '<u>BIRTHDAYS</u>';

  // Fetch clients with birthdays from the server
  showLoadingBar(); // Optional: Show loading indicator
  google.script.run.withSuccessHandler(function(clients) {
    hideLoadingBar(); // Hide loading indicator

    var currentMonth = new Date().getMonth() + 1; // Months are 0-indexed, so add 1

    // Separate clients into currentMonthClients and restOfYearClients
    var currentMonthClients = [];
    var restOfYearClients = [];
    var clientsWithoutBirthdays = [];

    clients.forEach(function(client) {
      if (client.birthday) {
        if (client.month === currentMonth) {
          currentMonthClients.push(client);
        } else {
          restOfYearClients.push(client);
        }
      } else {
        clientsWithoutBirthdays.push(client);
      }
    });

    // Display current month clients
    showClients(currentMonthClients, clientsDisplay);

    // Create REST OF THE YEAR button if there are more clients
    if (restOfYearClients.length > 0) {
      var restButton = document.createElement('button');
      restButton.id = 'restOfYearButton';
      restButton.textContent = 'REST OF THE YEAR';
      restButton.className = 'secondary-button';
      clientsDisplay.appendChild(restButton);

      var restClientsContainer = document.createElement('div');
      restClientsContainer.style.display = 'none'; // Hide initially
      clientsDisplay.appendChild(restClientsContainer);

      restButton.onclick = function() {
        if (restClientsContainer.style.display === 'none') {
          restClientsContainer.style.display = 'block';
          restButton.textContent = 'HIDE REST OF THE YEAR';
          showClients(restOfYearClients, restClientsContainer);
        } else {
          restClientsContainer.style.display = 'none';
          restButton.textContent = 'REST OF THE YEAR';
        }
      };
    }

    // Display clients without birthdays at the end
    if (clientsWithoutBirthdays.length > 0) {
      clientsDisplay.appendChild(document.createElement('hr'));
      showClients(clientsWithoutBirthdays, clientsDisplay);
    }
  }).getClientsWithBirthdays();
}

function showClients(clients, container) {
  clients.forEach(function(client) {
    var clientDiv = document.createElement('div');
    clientDiv.style.cssText = "font-size: 16px; margin-bottom: 10px; position: relative;";

    // Create a button for the client name
    var clientNameButton = document.createElement('button');
    clientNameButton.className = 'inline-button client-button';
    clientNameButton.innerText = client.name;
    clientNameButton.onclick = function() {
      selectClientFromButton(client.name);
    };
    clientDiv.appendChild(clientNameButton);

    // Display birthday
    var birthdaySpan = document.createElement('span');
    birthdaySpan.style.cssText = "margin-left: 10px;";
    if (client.birthday) {
      var month = client.month;
      var day = client.day;
      var formattedBirthday = (month < 10 ? '0' + month : month) + '/' + (day < 10 ? '0' + day : day);
      birthdaySpan.textContent = ' - ' + formattedBirthday;
    } else {
      birthdaySpan.textContent = ' - Unknown Birthday';
    }
    clientDiv.appendChild(birthdaySpan);

    container.appendChild(clientDiv);
    container.appendChild(document.createElement('hr'));
  });
}





function showTodaysTasks() {
    var displayAreaId = 'todaysTasksDisplay';
    var displayArea = document.getElementById(displayAreaId);

    if (displayArea.style.display === 'none' || displayArea.style.display === '') {
        showLoadingBar();

        google.script.run.withSuccessHandler(function(data) {
            displayTasksToday(data, displayAreaId, 'TODAY'); // Display tasks as before
            // createClientButtons(data.clients); // Create buttons for each client
            hideLoadingBar();
        }).getTasksForDay(0);
    } else {
        displayArea.style.display = 'none';
    }
}

function createClientButtons(clients) {
    var displayArea = document.getElementById('todaysTasksDisplay');
    // Add a style to align items to the left
    displayArea.style.textAlign = 'left';

    clients.forEach(function(client) {
        var button = document.createElement('button');
        button.innerText = client;
        button.onclick = function() {
            loadClient(client.split(' - ')[0]); // Assuming client name is before the '-'
            scrollToTop();
        };
        displayArea.appendChild(button);
    });
}


function loadClient(clientName) {
    console.log("loadClient called with:", clientName); // Log the client name passed to the function

    var clientSelect = document.getElementById('clientSelect');
    var options = Array.from(clientSelect.options);
    var clientOption = options.find(option => option.text === clientName);

    if (clientOption) {
        console.log("Matching option found:", clientOption.text); // Log if a matching option is found
        clientSelect.value = clientOption.value;
    } else {
        console.log("No matching option found for:", clientName); // Log if no matching option is found
        var newOption = new Option(clientName, clientName);
        clientSelect.add(newOption);
        clientSelect.value = clientName;
    }

    showClientNotes();
}





function displayTasksToday(data, displayAreaId, datePrefix) {
    var datePrefix = 'OVER THE NEXT 10 DAYS';
  var formattedDate = getFormattedDate(0);
  var clients = data.clients; // Assuming 'clients' contains the list of client names from column A
  displayAppointmentsOnly(data, displayAreaId, datePrefix, formattedDate, clients);
}





function displayAppointmentsOnly(data, displayAreaId, datePrefix, clients) {
  var displayArea = document.getElementById(displayAreaId);

  // Update the displayArea innerHTML with the date
  displayArea.innerHTML = `<strong>APPOINTMENTS ${datePrefix}:</strong><br>`;

  // Filter to keep only appointments
  var appointments = data.calendarEvents.filter(event => event.startsWith('APPOINTMENT:'));

  // Display appointments
  if (appointments.length > 0) {
    appointments.forEach(function(appointment) {
      var appointmentDetails = appointment.match(/APPOINTMENT: (.*?) - (.+? to .+?) -/);
      if (appointmentDetails && appointmentDetails.length > 2) {
        var timeRange = appointmentDetails[2].split(' to ');
        var eventDate = new Date(timeRange[0]);
        var weekday = eventDate.toLocaleDateString(undefined, { weekday: 'long' });
        var day = eventDate.toLocaleDateString(undefined, { day: 'numeric', month: 'long' });

        var startTime = formatDateToHHMM(timeRange[0]);
        var endTime = formatDateToHHMM(timeRange[1]);

        var clientName = appointmentDetails[1];
        var isHighlighted = clients.includes(clientName) ? 'highlighted' : '';

        displayArea.innerHTML += `<div class="${isHighlighted}">${weekday}, ${day} - ${clientName} - ${startTime} to ${endTime}</div>`;
      }
    });
  } else {
    displayArea.innerHTML += 'NONE<br>';
  }

  // Ensure the content is displayed
  displayArea.style.display = 'block';
}







function formatDateToHHMM(timeString) {
  const time = timeString.match(/(\d+):(\d+)/);
  if (!time) return 'Invalid Time';

  let hours = parseInt(time[1], 10);
  const minutes = parseInt(time[2], 10);

  // Convert 24-hour time to 12-hour format
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  hours = hours ? hours : 12; // the hour '0' should be '12'

  return hours + ':' + minutes.toString().padStart(2, '0') + ' ' + ampm;
}



function getFormattedDate(offset) {
  var date = new Date();
  date.setDate(date.getDate() + offset);
  var dd = String(date.getDate()).padStart(2, '0');
  var mm = String(date.getMonth() + 1).padStart(2, '0');
  return mm + '/' + dd;
}

function updateCategoryLabel() {
    var clientSelect = document.getElementById('clientSelect');
    var categorySelect = document.getElementById('categorySelect');
    var selectedOption = clientSelect.options[clientSelect.selectedIndex];

    if (clientSelect.value) {
        // Extract client name and category from the selected option
        var clientName = selectedOption.value;
        var clientCategory = selectedOption.textContent.split(' (')[1].slice(0, -1);

        // Updating only the placeholder for the category selection dropdown
        categorySelect.options[0].text = 'Change Category for ' + clientName + ' (' + clientCategory + ')';
    } else {
        // Set the placeholder text when no client is selected
        categorySelect.options[0].text = 'Select a category...';
    }
}




function populateLabelsDropdown(labels) {
    var dropdown = document.getElementById('labelsDropdown');
    dropdown.innerHTML = ''; // Clear existing options

    // Add a disabled and selected placeholder option at the beginning
    var placeholderOption = document.createElement('option');
    placeholderOption.value = "";
    placeholderOption.textContent = "Add Label";
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    dropdown.appendChild(placeholderOption);

    // Remove "NEW LABEL" from the array if it exists
    var newLabelIndex = labels.indexOf("NEW LABEL");
    if (newLabelIndex > -1) {
        labels.splice(newLabelIndex, 1);
    }

    // Add the "NEW LABEL" option after the placeholder
    var newLabelOption = document.createElement('option');
    newLabelOption.value = "NEW LABEL";
    newLabelOption.textContent = "NEW LABEL";
    dropdown.appendChild(newLabelOption);

    // Sort the remaining labels alphabetically
    labels.sort();

    // Dynamic label options
    labels.forEach(function(label) {
        var option = document.createElement('option');
        option.value = label;
        option.textContent = label;
        dropdown.appendChild(option);
    });
}





function addLabelToClient(label) {
    var clientSelect = document.getElementById('clientSelect');
    var clientName = clientSelect.value;

    if (label === "NEW LABEL") {
        // Prompt user to enter the new label name
        var newLabel = prompt("Please enter the new label name:");
        if (newLabel) {
            // Call server-side function to add the new label to the client
            google.script.run.withSuccessHandler(function() {
                alert("New label added successfully!");
                showClientNotes(); // Refresh to show the new label
            }).addLabelToClient(clientName, newLabel);
        }
    } else {
        // Existing logic to add existing label to client
        google.script.run.withSuccessHandler(function() {
            alert("Label added successfully!");
            showClientNotes(); // Refresh to show the added label
        }).addLabelToClient(clientName, label);
    }
}



function refreshClientDetails(clientName) {
  // Implement the logic to refresh client details here.
  // This could be a call to the function that initially loads the client details.
  showClientNotes(); // Example: Refresh client notes or any other relevant information
}


document.getElementById('loadNotesButton').addEventListener('click', function() {
    showLoadingBar(); // Start loading as soon as the button is clicked
    displayTodayNotes(notes); // Assuming 'notes' is your data source
});

function displayTodayNotes(notes) {
    var displayArea = document.getElementById('notesDisplayArea');

    if (displayArea.style.display === 'none' || displayArea.style.display === '') {
        var formattedNotes = notes.map(function(item) {
            var noteDisplay = item.isPastNote ? '⭐ ' + item.note : item.note;
            return noteDisplay.replace(/\n/g, '<br>');
        }).join('<br><br>');

        displayArea.innerHTML = formattedNotes;
        displayArea.style.display = 'block';
    } else {
        displayArea.style.display = 'none';
    }

    hideLoadingBar(); // Hide the loading bar after rendering the notes
}


// REPLACEMENT: populateCategoryDropdown — fills #categorySelect with unique Column F values (A→Z)
function populateCategoryDropdown(categories) {
  var sel = document.getElementById('categorySelect');
  if (!sel) return;

  sel.innerHTML = '';

  var ph = document.createElement('option');
  ph.value = '';
  ph.textContent = 'Select a category...';
  sel.appendChild(ph);

  (categories || []).forEach(function (cat) {
    var opt = document.createElement('option');
    opt.value = cat;
    opt.textContent = cat;
    sel.appendChild(opt);
  });

  var newOpt = document.createElement('option');
  newOpt.value = '__NEW__';
  newOpt.textContent = 'NEW CATEGORY…';
  sel.appendChild(newOpt);

  // 🔧 One unified handler for both cases
  if (!sel._wiredChange) {
    sel.addEventListener('change', function () {
      if (this.value === '__NEW__') {
        this.value = '';
        openNewCategoryModal();
        return;
      }
      if (this.value) {
        updateCategory();                 // <- saves to sheet
        if (typeof updateCategoryLabel === 'function') updateCategoryLabel();
      }
    });
    sel._wiredChange = true;
  }
}




// Call the function at the end of the script to automatically execute it on page load
// displayTopClients();

function updateClientColumnBFromNotes(newValue) {
  var clientName = document.getElementById('clientSelect').value;

  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // Refresh the top clients display
      displayTopClients();
    })
    .withFailureHandler(function(error) {
      hideLoadingBar();
      alert('Failed to update Column B: ' + error);
    })
    .updateClientColumnB(clientName, newValue);
}

function updateClientColumnDFromNotes(newValue) {
  var clientName = document.getElementById('clientSelect').value;

  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // Refresh the top clients display
      displayTopClients();
    })
    .withFailureHandler(function(error) {
      hideLoadingBar();
      alert('Failed to update Column D: ' + error);
    })
    .updateClientColumnD(clientName, newValue);
}




function saveClientData(clientName, newData) {
    showLoadingBar(); // Optionally show a loading indicator

    google.script.run.withSuccessHandler(function() {
        hideLoadingBar(); // Hide loading bar on success
        alert('Data saved successfully.'); // Notify the user
        displayTopClients(); // Refresh the display for top clients
    }).updateClientData(clientName, newData); // Implement this Google Apps Script function
}

function toggleAdvanced() {
    var container = document.getElementById('advancedContainer');
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function toggleGraphs() {
    var container = document.getElementById('graphsContainer');
    container.style.display = container.style.display === 'none' ? 'block' : 'none';
}

function filterClients(day) {
  google.script.run.withSuccessHandler(displayClients).getTopClientsByDay(day);
}

function displayClients(clients) {
  const displayArea = document.getElementById('clientDisplay');
  displayArea.innerHTML = ''; // Clear previous entries
  clients.forEach(client => {
    const clientDiv = document.createElement('div');

    // Create a span for the client name with a smaller font size
    const nameSpan = document.createElement('span');
    nameSpan.textContent = client.name;
    nameSpan.style.fontSize = 'small';  // Adjust the font size as needed

    // Create a span for the latest follow-up with a smaller font size
    const followUpSpan = document.createElement('span');
    followUpSpan.textContent = `: ${client.latestFollowUp}`;
    followUpSpan.style.fontSize = 'small'; // Adjust the font size as needed

    // Append both spans to the div
    clientDiv.appendChild(nameSpan);
    clientDiv.appendChild(followUpSpan);

    displayArea.appendChild(clientDiv);
  });
}

    function hideClientNotes() {
    // Hide the client notes area
    document.getElementById('notesDisplay').innerHTML = '';
    document.getElementById('notesDisplay').style.display = 'none';

    // Hide all related UI sections
    document.getElementById('workSectionsContainer').style.display = 'none';
    document.getElementById('pastWorkSection').style.display = 'none';

    // Safety: Future Work section should stay hidden if it still exists
    var fw = document.getElementById('futureWorkSection');
    if (fw) fw.style.display = 'none';

    document.getElementById('categoryChangeSection').style.display = 'none';
    document.getElementById('appointmentInputSection').style.display = 'none';
    document.getElementById('addAppointmentBtn').style.display = 'none';
    document.getElementById('labelsAdditionSection').style.display = 'none';
    document.getElementById('hideClientNotesBtn').style.display = 'none';

    // Clear labels
    document.getElementById('labelsDisplay').innerHTML = '';

    // Reset autocomplete input
    var clientAutocomplete = document.getElementById('clientAutocomplete');
    clientAutocomplete.value = '';
    clientAutocomplete.style.color = '';

    // Reset current client global variable
    currentClientName = '';

    // Reset dropdown
    document.getElementById('clientSelect').value = '';

    // Clear loaded in-progress area
    var loadedArea = document.getElementById('loadedInProgressArea');
    if (loadedArea) loadedArea.value = '';

    // Clear chip data (columns P and Q)
    window.__chipForCurrentClient = {
        initials: '',
        date: ''
    };

    // Clear category selection
    document.getElementById('categorySelect').value = '';

    // Clear past work input
    document.getElementById('newPastWork').value = '';
}


    // Show Add New Client Modal
function displayAddNewClientModal() {
    // Open the modal
    var modal = document.getElementById('addClientModal');
    var modalContent = document.getElementById('addClientModalContent');
    modal.style.display = 'block';

    // Clear the modal content
    modalContent.innerHTML = '';

    // Add content to modal for Client Name input
    var clientNameLabel = document.createElement('label');
    clientNameLabel.textContent = 'Client Name:';
    var clientNameInput = document.createElement('input');
    clientNameInput.type = 'text';
    clientNameInput.id = 'modalClientName';
    clientNameInput.style.width = '100%';

    var nextButton = document.createElement('button');
    nextButton.textContent = 'Next';
    nextButton.onclick = function() {
        var clientName = clientNameInput.value.trim();
        if (!clientName) {
            alert('Please enter a client name.');
            return;
        }
        // Proceed to Category selection
        showCategorySelection(clientName);
    };

    modalContent.appendChild(clientNameLabel);
    modalContent.appendChild(clientNameInput);
    modalContent.appendChild(nextButton);
}

// Function to show Category selection
function showCategorySelection(clientName) {
    var modalContent = document.getElementById('addClientModalContent');
    modalContent.innerHTML = '';

    var categoryLabel = document.createElement('label');
    categoryLabel.textContent = 'Category:';
    var categorySelect = document.createElement('select');
    categorySelect.id = 'modalClientCategory';
    categorySelect.style.width = '100%';

    // Populate category options
    var categories = [
        '⭐⭐⭐⭐⭐',
        '⭐⭐⭐⭐',
        '⭐⭐⭐',
        '⭐⭐',
        '⭐',
    ];

    categories.forEach(function(category) {
        var option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
    });

    var submitButton = document.createElement('button');
    submitButton.textContent = 'Submit';
    submitButton.onclick = function() {
        var category = categorySelect.value;
        // Proceed to submit the new client
        submitNewClientModal(clientName, category);
    };

    modalContent.appendChild(categoryLabel);
    modalContent.appendChild(categorySelect);
    modalContent.appendChild(submitButton);
}

function submitNewClientModal(clientName, category) {
    // Close the modal
    var modal = document.getElementById('addClientModal');
    modal.style.display = 'none';

    // Prepare the data
    var futureWorkNote = ''; // Set empty if not collecting
    var pastWork = '';

    // Call the existing function to submit the new client
    google.script.run.withSuccessHandler(function(response) {
        alert('New client added: ' + clientName); // Notify success
        alert('PLEASE ADD FUTURE WORK IN ORDER FOR NEW CLIENT TO ENTER DASHBOARD WORKFLOW');

        // **Show the loading bar after the alerts**
        showLoadingBar();

        // Now set Column B to 'STRICT' for the new client
        google.script.run.withSuccessHandler(function(){
            // Refresh clientsData and the dropdown
            google.script.run.withSuccessHandler(function(data){
                clientsData = data;
                populateClientDropdown(clientsData);

                // Now select the new client in the dropdown
                var clientSelect = document.getElementById('clientSelect');
                var clientAutocomplete = document.getElementById('clientAutocomplete');

                for (var i = 0; i < clientSelect.options.length; i++) {
                    if (clientSelect.options[i].value === clientName) {
                        clientSelect.selectedIndex = i;
                        clientAutocomplete.value = clientSelect.options[i].text;
                        break;
                    }
                }
                // Now call showClientNotes()
                showClientNotes();
            }).getAllClientsData();
        }).updateClientColumnB(clientName, 'STRICT');
    }).addNewClientWithPastWork(clientName, futureWorkNote, category, pastWork);
}




// Function to close the modal
function closeAddClientModal() {
    var modal = document.getElementById('addClientModal');
    modal.style.display = 'none';
}

/**********************************************
REPLACE ENTIRE displayClient FUNCTION WITH THIS
**********************************************/
/**********************************************
  READ-ONLY Top Clients renderer
  - No inline note editing in the list
  - Chip is read-only in the list
  - Editing remains in client details after selecting a client
**********************************************/
/**********************************************
  READ-ONLY Top Clients renderer (keeps original layout)
  + Adds green Ricky’s Suggestion block (hidden by default)
**********************************************/
function displayClient(client, container) {
  // Card wrapper (keep your existing task-display sizing)
  var clientDiv = document.createElement('div');
  clientDiv.className = 'task-display';
  clientDiv.style.display = 'flex';
  clientDiv.style.flexDirection = 'column';
  clientDiv.style.alignItems = 'flex-start';
  clientDiv.style.marginBottom = '10px';

  /* ── Top row: Client button ONLY (no day-of-week dropdown in Top Clients list) ── */
  var topRow = document.createElement('div');
  topRow.style.cssText = "display:flex; align-items:center;";

  var clientButton = document.createElement('button');
  clientButton.className = 'inline-button client-button';
  clientButton.innerText = client.name + (client.category ? ' (' + client.category + ')' : '');
  clientButton.style.cssText = "display:inline-flex; align-items:center;";
  clientButton.addEventListener('click', function () {
    // prime chip cache so details view shows same chip
    window.__chipForCurrentClient = {
      initials: (client.chipInitials || '').toUpperCase(),
      date: normalizeChipDate(client.chipDate || '')
    };
    selectClientFromButton(client.name);
  });
  topRow.appendChild(clientButton);

  clientDiv.appendChild(topRow);

  /* ── Notes highlight section (read-only in list) ── */
  var allC = [];
  (client.pastWorks || []).forEach(function(pw){
    String(pw || '').split('\n').forEach(function(line){
      var t = (line || '').trim();
      if (t) allC.push(t);
    });
  });

  if (allC.length > 0) {
    function parseMDY(line){
      var m = String(line).match(/\b(\d{1,2})\/(\d{1,2})\/(\d{2,4})\b/);
      if (!m) return null;
      var mm=+m[1], dd=+m[2], yy=+m[3]; if (yy<100) yy+=2000;
      return new Date(yy, mm-1, dd);
    }
    function safeFormatNoteHTML(s){
      return typeof formatNoteHTML === 'function' ? formatNoteHTML(s)
        : String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    var withDates=[], noDates=[];
    allC.forEach(function(line){
      var d=parseMDY(line);
      if(d) withDates.push({line,d}); else noDates.push({line});
    });
    withDates.sort(function(a,b){ return a.d - b.d; });
    var sorted = withDates.map(x=>x.line).concat(noDates.map(x=>x.line));

    var notesWrap = document.createElement('div');
    notesWrap.style.cssText = "display:flex; flex-direction:column; align-items:stretch; margin-top:5px; width:100%;";

    // Older notes container (remains hidden, and no MORE button in the list)
    var olderWrap = document.createElement('div');
    olderWrap.style.cssText = "display:none; flex-direction:column; gap:5px;";
    notesWrap.appendChild(olderWrap);

    // Highlighted (newest 3) container
    var hiWrap = document.createElement('div');
    hiWrap.style.cssText = "display:flex; flex-direction:column; gap:5px;";
    notesWrap.appendChild(hiWrap);

    var lastIdx = sorted.length - 1;
    var hiCount = Math.min(3, sorted.length);
    var firstHi = lastIdx - (hiCount - 1);

    sorted.forEach(function(line, i){
      var div = document.createElement('div');
      div.className = 'note-line';
      div.style.fontSize = '32px';
      div.style.marginBottom = '0px';
      div.innerHTML = safeFormatNoteHTML(line);

      if (i >= firstHi) {
        // HIGHLIGHTED
        div.classList.add('latest-note');
        div.style.backgroundColor = 'yellow';
        hiWrap.appendChild(div);

        // Newest line gets chip (read-only edit still opens chip editor if clicked)
        if (i === lastIdx) {
          var chipEl = createChipElement(
            client.name,
            (client.chipInitials || "").toUpperCase(),
            client.chipDate || ""
          );
          div.appendChild(chipEl);
        }
      } else {
        // OLDER — stays hidden (no MORE button to reveal)
        div.classList.add('older-note');
        div.style.display = 'none';
        olderWrap.appendChild(div);
      }
    });

    // (list remains read-only)
    clientDiv.appendChild(notesWrap);
  }

  /* ── Ricky’s Suggestion (Column L) — green block; obeys global toggle; unchanged ── */
  var sugWrap = document.createElement('div');
  sugWrap.className = 'toplist-suggestion';
  sugWrap.style.display = 'none'; // toggled by your existing toggleSuggestions()
  sugWrap.style.alignSelf = 'stretch';   // ensure it spans the whole card width

  var lab = document.createElement('label');
  lab.style.fontWeight = 'bold';
  lab.style.display = 'block';
  lab.textContent = "💡";
  sugWrap.appendChild(lab);

  var ta = document.createElement('textarea');
  ta.className = 'note-textarea';
  ta.style.minHeight = '60px';
  ta.value = client.columnLContent || '';
  ta.addEventListener('blur', function(){
    onToplistSuggestionBlur(client.name, ta.value); // saves Column L then reloads (your code)
  });
  sugWrap.appendChild(ta);

  clientDiv.appendChild(sugWrap);

  /* ── Thick divider like before ── */
  var thickLine = document.createElement('hr');
  thickLine.style.cssText = "width:100%; border:3px solid black; margin:10px 0;";
  clientDiv.appendChild(thickLine);

  container.appendChild(clientDiv);

  // Respect current Suggestions toggle state
  if (typeof applySuggestionsVisibility === 'function') applySuggestionsVisibility();
}



function updateCategorySelectValue(clientCategory) {
    var categorySelect = document.getElementById('categorySelect');
    if (clientCategory) {
        // Ensure the category exists in the dropdown
        var optionExists = Array.from(categorySelect.options).some(function(option) {
            return option.value === clientCategory;
        });

        // If not, add it to the dropdown
        if (!optionExists) {
            var newOption = document.createElement('option');
            newOption.value = clientCategory;
            newOption.textContent = clientCategory;
            categorySelect.appendChild(newOption);
        }

        // Set the dropdown's value to the client's category
        categorySelect.value = clientCategory;
    } else {
        categorySelect.value = '';
    }
}


function displayTopClientsByCategory() {
    showLoadingBar(); // Optional: show loading indicator

    google.script.run.withSuccessHandler(function(clients) {
        var categoryCounts = {};

        // Define the same variables and logic used in showTopClients function
        var now = new Date();
        var sevenDaysFromNow = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now
        var todayIndex = now.getDay();
        var daysOfWeek = ['Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'];
        var todayDay = daysOfWeek[todayIndex];

        // Filter clients based on the 'strictPast' filter logic
        var filteredClients = clients.filter(function(client) {
            var latestDate = null;
            client.followUps.forEach(function(followUp) {
                var followUpLines = followUp.split('\n');
                followUpLines.forEach(function(line) {
                    var dates = line.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
                    if (dates) {
                        var dateParts = dates[0].split('/');
                        var date = new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
                        if (!latestDate || date > latestDate) {
                            latestDate = date;
                        }
                    }
                });
            });
            client.latestDate = latestDate; // Store the latestDate in client for sorting

            // Apply the same filtering conditions as in 'strictPast'
            return client.columnB === "STRICT" && latestDate && latestDate <= sevenDaysFromNow;
        });

        // Separate clients matching today and rest of the week
        var clientsMatchingToday = [];
        var otherClients = [];

        filteredClients.forEach(function(client) {
            if (client.columnD === todayDay) {
                clientsMatchingToday.push(client);
            } else {
                otherClients.push(client);
            }
        });

        // Combine clients to reflect the ones displayed on page load
        var strictPastClients = clientsMatchingToday.concat(otherClients);

        // Count categories from the combined list
        strictPastClients.forEach(function(client) {
            var category = client.category || 'Uncategorized';
            if (categoryCounts[category]) {
                categoryCounts[category]++;
            } else {
                categoryCounts[category] = 1;
            }
        });

        // Build the HTML content
        var content = '';
        for (var category in categoryCounts) {
            content += '<p>' + category + ': ' + categoryCounts[category] + '</p>';
        }

        // Display the modal with the content
        document.getElementById('categoriesModalContent').innerHTML = content;
        document.getElementById('categoriesModal').style.display = 'block';
        hideLoadingBar(); // Hide loading indicator
    }).getTopClients();
}



function closeCategoriesModal() {
    document.getElementById('categoriesModal').style.display = 'none';
}

function triggerTopClientsEmail() {
  // Show a quick "loading" bar if you want
  showLoadingBar();

  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      alert("Email summary sent successfully!");
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Failed to send email summary. Error: " + err.message);
    })
    .sendDailyTopClientsEmail();  // <-- Must match the function name in Code.gs
}

// This function creates a big star overlay, shows it for ~5s, then removes it
function showStarAnimation() {
  // Create the DIV
  var starDiv = document.createElement('div');
  starDiv.className = 'star-animation';
  document.body.appendChild(starDiv);

  // Remove after 5 seconds
  setTimeout(function() {
    if (starDiv && starDiv.parentNode) {
      starDiv.parentNode.removeChild(starDiv);
    }
  }, 2500);
}

/*******************************************************
 SNIPPET #3: Real-time “In Progress” sync & save
*******************************************************/
/*******************************************************
 SNIPPET #3: Real-time “In Progress” sync & save (UPDATED)
*******************************************************/

function onInProgressChange(clientName, newValue) {
  // Show the loading bar BEFORE calling the server
  showLoadingBar();

  // 1) Immediately call Apps Script to store in Column L
  google.script.run
    .withSuccessHandler(function() {
      // Hide the loading bar AFTER success
      hideLoadingBar();

      // 2) If successful, mirror that newValue into the loaded client area (if it’s the same client)
      updateInProgressDom(clientName, newValue);
    })
    .withFailureHandler(function(err) {
      // Hide the loading bar even if it fails
      hideLoadingBar();
      console.error("Failed to update column L:", err);
    })
    .updateClientData(clientName, newValue); // Reuses your existing updateClientData() in Code.gs
}

/* ===== REPLACEMENT: onInProgressLoadedBlur (no full refresh) ===== */
function onInProgressLoadedBlur(valueFromUI) {
  // Find current client name from the picker
  var clientName = (document.getElementById('clientSelect') || {}).value || '';
  if (!clientName) return; // nothing to save against

  var ta = document.getElementById('loadedInProgressArea');
  if (!ta) return;

  // Don’t do anything if text hasn't changed
  var newVal = String(valueFromUI || '');
  var oldVal = String(ta.getAttribute('data-last-saved') || '');
  if (newVal.trim() === oldVal.trim()) return;

  // Optional: tiny spinner cue at field level (keep your global bar too if you like)
  if (typeof showLoadingBar === 'function') showLoadingBar();

  google.script.run
    .withSuccessHandler(function () {
      // Lock in the new value locally, NO full re-render
      ta.setAttribute('data-last-saved', newVal);

      // Small inline “Saved” badge (reuse the helper you already have)
      if (typeof showInlineSavedBadge === 'function') showInlineSavedBadge(ta);

      if (typeof hideLoadingBar === 'function') hideLoadingBar();

      // ✅ DO NOT call displayTopClients(), showTopClients(), getTopClients(), etc. here
      reloadPreservingState();

    })
    .withFailureHandler(function (err) {
      alert('Error saving In Progress: ' + (err && err.message ? err.message : err));
      // Revert UI to the last saved text
      ta.value = oldVal;
      if (typeof hideLoadingBar === 'function') hideLoadingBar();
    })
    // ⬇️ change to your server function name if different
    .updateClientColumnL(clientName, newVal);
}
/* ===== END REPLACEMENT ===== */



// This function updates all “In Progress:” textareas on the page for the given client
// so they match the newly saved value, WITHOUT reloading.
function updateInProgressDom(clientName, newValue) {
  // 1) If the loaded client is the same, update the loadedInProgressArea
  var currentlySelected = document.getElementById('clientSelect').value;
  if (currentlySelected === clientName) {
    var loadedText = document.getElementById('loadedInProgressArea');
    if (loadedText && loadedText.value !== newValue) {
      loadedText.value = newValue;
    }
  }

  // 2) Update the “In Progress:” textareas in the top clients list
  //    (They have .className = "inProgressArea" plus a data-client attribute)
  var allAreas = document.querySelectorAll('.inProgressArea[data-client="' + clientName + '"]');
  allAreas.forEach(function(area) {
    if (area.value !== newValue) {
      area.value = newValue;
    }
  });
}
// UPDATED: Handle JB / RB / QC filters and update topClientsTitle
function handleTopClientsFilterChange(selectedFilter) {
  // Dynamically update the top title when JB / RB / QC are chosen
  var titleEl = document.getElementById('topClientsTitle');
  if (selectedFilter === 'JB' || selectedFilter === 'RB' || selectedFilter === 'TEAM' || selectedFilter === 'QC') {
    titleEl.innerText = selectedFilter; // Set to "JB", "RB", or "QC"
  } else if (selectedFilter === 'ALL') {
    titleEl.innerText = 'TOP CLIENTS';
  }

  switch (selectedFilter) {
    case 'ALL':
      displayFilteredClients('all');
      break;

    // === NEW: filter by chip initials in Column P ===
    case 'JB':
    case 'RB':
    case 'TEAM':
    case 'QC':
      showLoadingBar();
      google.script.run.withSuccessHandler(function(clients){
        var target = selectedFilter; // 'JB' | 'RB' | 'QC'
        var filtered = clients.filter(function(c){
          return (String(c.chipInitials || '').toUpperCase() === target);
        });
        showTopClients(filtered, 'all');
        hideLoadingBar();
      }).getTopClients();
      break;

    // Emoji filters (existing)
    case 'BRIEFCASE':
      showLoadingBar();
      google.script.run.withSuccessHandler(function(clients){
        let filtered = clients.filter(function(c){
          return c.columnLContent && c.columnLContent.includes("💼");
        });
        showTopClients(filtered, 'all');
        hideLoadingBar();
      }).getTopClients();
      break;

    case 'STAR':
      showLoadingBar();
      google.script.run.withSuccessHandler(function(clients){
        let filtered = clients.filter(function(c){
          return c.columnLContent && c.columnLContent.includes("⭐");
        });
        showTopClients(filtered, 'all');
        hideLoadingBar();
      }).getTopClients();
      break;

    case 'GRADCAP':
      showLoadingBar();
      google.script.run.withSuccessHandler(function(clients){
        let filtered = clients.filter(function(c){
          return c.columnLContent && c.columnLContent.includes("🎓");
        });
        showTopClients(filtered, 'all');
        hideLoadingBar();
      }).getTopClients();
      break;

    case 'PHONE':
      showLoadingBar();
      google.script.run.withSuccessHandler(function(clients){
        let filtered = clients.filter(function(c){
          return c.columnLContent && c.columnLContent.includes("📞");
        });
        showTopClients(filtered, 'all');
        hideLoadingBar();
      }).getTopClients();
      break;
  }
}



function showTasksFromSpreadsheet() {
  // Show the container
  document.getElementById('updateTasksContainer').style.display = 'block';

  // Clear the current listing
  document.getElementById('tasksList').innerHTML = '';

  // Show loading bar
  showLoadingBar();

  // Call server function getTasksForDashboardIntegration() [defined in .gs snippet below]
  google.script.run
    .withSuccessHandler(function(tasksArray) {
      hideLoadingBar();

      if (!tasksArray || tasksArray.length === 0) {
        document.getElementById('tasksList').innerHTML =
          "<p>No tasks found in the Tasks spreadsheet.</p>";
        return;
      }

      tasksArray.forEach(function(taskObj, idx) {
        addTaskRowToDOM(taskObj, idx);
      });
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Failed to fetch tasks: " + err.message);
    })
    .getTasksForDashboardIntegration();
}

/**
 * Renders one row for a given task in the #tasksList div.
 */
function addTaskRowToDOM(taskObj, idx) {
  var container = document.getElementById('tasksList');

  // Outer wrapper
  var rowDiv = document.createElement('div');
  rowDiv.style.border = '1px solid #ccc';
  rowDiv.style.padding = '10px';
  rowDiv.style.marginBottom = '10px';
  rowDiv.id = 'taskRow_' + idx;

  // The raw task text
  var taskTitle = document.createElement('div');
  taskTitle.innerHTML = "<b>Task:</b> " + taskObj.fullTask;
  rowDiv.appendChild(taskTitle);
taskTitle.style.fontSize = '0.5em'; 

// Automatically fetch 5 matches (no guess button).
var namePart = extractNameFromTask(taskObj.fullTask);
fetchClosestMatches(namePart, function(matches) {
    showMatchesDropdown(rowDiv, matches, taskObj);
});


  // Spot to show the dropdown of matches
  var matchesDiv = document.createElement('div');
  matchesDiv.id = 'matchesDiv_' + idx;
  rowDiv.appendChild(matchesDiv);

  container.appendChild(rowDiv);
}

/**
 * Extract the first 2 or 3 words from the task, assuming "Name" is at the start of the text.
 */
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * UPDATED extractNameFromTask
 * Paste in the exact spot you removed the old function
 ******************************************************/
/******************************************************
 * FIXED extractNameFromTask
 * REMOVED logic around "for", "couple", "&", "and"
 * NOW returns the entire task string so we match any name
 ******************************************************/
function extractNameFromTask(fullTask) {
  if (!fullTask) return "";
  // This new version just returns the entire trimmed text
  // so name-finding can work on the full string.
  return fullTask.trim();
}






/**
 * Calls the server to find 5 closest matches in Dashboard 8.0 Column A.
 */
function fetchClosestMatches(namePart, callback) {
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function(matches) {
      hideLoadingBar();
      callback(matches);
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Error finding closest matches: " + err.message);
      callback([]); // fallback
    })
    .getClosestClients(namePart, 5); // We'll define getClosestClients() in Code.gs
}

//-----------------------------------------------
// showMatchesDropdown(rowDiv, matches, taskObj)
// REPLACE your entire old function with this
//-----------------------------------------------
function showMatchesDropdown(rowDiv, matches, taskObj) {
  /*1*/  var matchesDiv = rowDiv.querySelector('div[id^="matchesDiv_"]');
  /*2*/  matchesDiv.innerHTML = ''; // Clear any existing content

  /*3*/  if (!matches || matches.length === 0) {
  /*4*/    matchesDiv.innerHTML = '<p>No matches found.</p>';
  /*5*/    return; // Done if no matches
  /*6*/  }

  /*7*/  // We'll build a UL containing the normal matches
  /*8*/  var clientList = document.createElement('ul');
  /*9*/  clientList.style.listStyle = 'none';
  /*10*/ clientList.style.padding = '0';
  /*11*/ clientList.style.marginBottom = '5px';

  /*12*/ // We'll track which client is selected from among the normal 5
  /*13*/ var selectedClient = null;

  /*14*/ // Build the normal 5 matches as LI elements
  /*15*/ matches.forEach(function(clientName) {
  /*16*/   var li = document.createElement('li');
  /*17*/   li.innerText = clientName;
  /*18*/   li.style.cursor = 'pointer';
  /*19*/   li.style.padding = '4px 8px';
  /*20*/   li.style.border = '1px solid #ccc';
  /*21*/   li.style.borderRadius = '4px';
  /*22*/   li.style.marginBottom = '3px';
  /*23*/   li.style.fontSize = '0.33em';

  /*24*/   li.onclick = function() {
  /*25*/     // Remove highlighting from everything:
  /*26*/     Array.from(clientList.children).forEach(child => {
  /*27*/       child.style.backgroundColor = '';
  /*28*/       child.style.fontWeight = '';
  /*29*/     });
  /*30*/     // Highlight THIS <li>
  /*31*/     li.style.backgroundColor = '#e0e0e0';
  /*32*/     li.style.fontWeight = 'bold';
  /*33*/     // Set selectedClient
  /*34*/     selectedClient = clientName;
  /*35*/   };

  /*36*/   clientList.appendChild(li);
  /*37*/ }); 
  // AFTER this closing brace is where we'll paste the snippet

  /************************************************************
   SNIPPET: ADD THE 6TH "AUTOCOMPLETE" ROW
   PASTE THIS EXACT BLOCK AFTER LINE 37, BEFORE CONTINUING CODE
  ************************************************************/
  /*38*/ // === SNIPPET START: 6th suggestion (autocomplete) ===
  /*39*/ var li6 = document.createElement('li');
  /*40*/ li6.style.cursor = 'default';
  /*41*/ li6.style.padding = '4px 8px';
  /*42*/ li6.style.border = '1px solid #ccc';
  /*43*/ li6.style.borderRadius = '4px';
  /*44*/ li6.style.marginBottom = '3px';
  /*45*/ li6.style.fontSize = '0.33em';
  /*46*/ li6.style.backgroundColor = '#f9f9f9';
  /*47*/ li6.innerText = 'Enter any client name:'; // label at the top

  /*48*/ // The manual input
  /*49*/ var manualInput = document.createElement('input');
  /*50*/ manualInput.type = 'text';
  /*51*/ manualInput.style.width = '100%';
  /*52*/ manualInput.style.marginTop = '3px';
  /*53*/ manualInput.style.fontSize = '16px';
  /*54*/ manualInput.placeholder = 'Type to search all clients...';

  /*55*/ var isUsingManualChoice = false;     // true if user picks from 6th row
  /*56*/ var manualChosenClient = null;       // which client was chosen

  /*57*/ // subSuggestions container
  /*58*/ var subSuggestions = document.createElement('div');
  /*59*/ subSuggestions.style.position = 'relative';
  /*60*/ subSuggestions.style.backgroundColor = '#ffffff';
  /*61*/ subSuggestions.style.border = '1px solid #ccc';
  /*62*/ subSuggestions.style.marginTop = '2px';
  /*63*/ subSuggestions.style.zIndex = '9999';
  /*64*/ subSuggestions.style.display = 'none'; // hidden by default

  /*65*/ li6.appendChild(manualInput);
  /*66*/ li6.appendChild(subSuggestions);

  /*67*/ function highlightLi6() {
  /*68*/   // Clear highlight from the first 5
  /*69*/   Array.from(clientList.children).forEach(child => {
  /*70*/     child.style.backgroundColor = '';
  /*71*/     child.style.fontWeight = '';
  /*72*/   });
  /*73*/   // highlight this 6th row
  /*74*/   li6.style.backgroundColor = '#e0e0e0';
  /*75*/   li6.style.fontWeight = 'bold';
  /*76*/ }

  /*77*/ // oninput -> show sub-suggestions from global clientsData
  /*78*/ manualInput.addEventListener('input', function() {
  /*79*/   var partial = manualInput.value.trim().toLowerCase();
  /*80*/   subSuggestions.innerHTML = '';
  /*81*/   subSuggestions.style.display = 'none';

  /*82*/   if (!partial) {
  /*83*/     manualChosenClient = null;
  /*84*/     isUsingManualChoice = false;
  /*85*/     li6.style.backgroundColor = '#f9f9f9';
  /*86*/     li6.style.fontWeight = '';
  /*87*/     return;
  /*88*/   }

  /*89*/   // Filter from your global clientsData
  /*90*/   var matched = clientsData.filter(function(clientObj) {
  /*91*/     return clientObj.clientName.toLowerCase().includes(partial);
  /*92*/   });

  /*93*/   if (matched.length === 0) return;
  /*94*/   subSuggestions.style.display = 'block';
  /*95*/   subSuggestions.style.maxHeight = '180px';
  /*96*/   subSuggestions.style.overflowY = 'auto';

  /*97*/   matched.forEach(function(cObj) {
  /*98*/     var div = document.createElement('div');
  /*99*/     div.style.padding = '4px';
  /*100*/    div.style.cursor = 'pointer';
  /*101*/    div.style.borderBottom = '1px solid #eee';
  /*102*/    div.innerText = cObj.clientName + (cObj.category ? ' (' + cObj.category + ')' : '');
  /*103*/    div.onclick = function() {
  /*104*/      manualChosenClient = cObj.clientName;
  /*105*/      manualInput.value = div.innerText;
  /*106*/      subSuggestions.innerHTML = '';
  /*107*/      subSuggestions.style.display = 'none';
  /*108*/      isUsingManualChoice = true;
  /*109*/      highlightLi6();
  /*110*/    };
  /*111*/    subSuggestions.appendChild(div);
  /*112*/  });
  /*113*/ });

  /*114*/ // blur -> hide subSuggestions
  /*115*/ manualInput.addEventListener('blur', function() {
  /*116*/   setTimeout(function() {
  /*117*/     subSuggestions.innerHTML = '';
  /*118*/     subSuggestions.style.display = 'none';
  /*119*/   }, 200);
  /*120*/ });

  /*121*/ // We'll override the existing applyBtn.onclick to handle manual picks
  /*122*/ // But first, we need a reference to the existing applyBtn:
  //        We'll define applyBtn later below (lines ~161), so we’ll "inject"
  //        the logic after we create it. We do so with a small trick shown below.
  /*123*/ 
  /*124*/ // We won't finalize li6 into the UL until after we define the rest.
  /*125*/ // === SNIPPET END: 6th suggestion ===

  /*126*/ // Now that we've built clientList, add it to matchesDiv
  /*127*/ matchesDiv.appendChild(clientList);

  /*128*/ // Build radio container for Past/Future
  /*129*/ var radioContainer = document.createElement('div');
  /*130*/ radioContainer.style.marginTop = '5px';
  /*131*/ radioContainer.style.fontSize = '12px';

  /*132*/ var pastRadio = document.createElement('input');
  /*133*/ pastRadio.type = 'radio';
  /*134*/ pastRadio.name = 'workType_' + rowDiv.id;
  /*135*/ pastRadio.value = 'PAST';
  /*136*/ pastRadio.id = 'past_' + rowDiv.id;
  /*137*/ pastRadio.checked = true;

  /*138*/ var pastLabel = document.createElement('label');
  /*139*/ pastLabel.htmlFor = pastRadio.id;
  /*140*/ pastLabel.innerText = 'Past Work';

  /*141*/ var futureRadio = document.createElement('input');
  /*142*/ futureRadio.type = 'radio';
  /*143*/ futureRadio.name = 'workType_' + rowDiv.id;
  /*144*/ futureRadio.value = 'FUTURE';
  /*145*/ futureRadio.id = 'future_' + rowDiv.id;

  /*146*/ var futureLabel = document.createElement('label');
  /*147*/ futureLabel.htmlFor = futureRadio.id;
  /*148*/ futureLabel.innerText = 'Future Work';

  /*149*/ radioContainer.appendChild(pastRadio);
  /*150*/ radioContainer.appendChild(pastLabel);
  /*151*/ radioContainer.appendChild(document.createTextNode('  '));
  /*152*/ radioContainer.appendChild(futureRadio);
  /*153*/ radioContainer.appendChild(futureLabel);

  /*154*/ matchesDiv.appendChild(radioContainer);

  /*155*/ // Build the APPLY button
  /*156*/ var applyBtn = document.createElement('button');
  /*157*/ applyBtn.innerText = 'APPLY';
  /*158*/ applyBtn.style.marginTop = '5px';
  /*159*/ applyBtn.style.fontSize = '18px';

  /*160*/ // Original applyBtn onclick
  /*161*/ var oldApplyClick = function() {
  /*162*/   if (!selectedClient) {
  /*163*/     alert('Please select a client.');
  /*164*/     return;
  /*165*/   }
  /*166*/   var chosenWorkType = pastRadio.checked ? 'PAST' : 'FUTURE';
  /*167*/   doApplyTaskToClient(selectedClient, chosenWorkType, taskObj, rowDiv.id);
  /*168*/ };

  /*169*/ applyBtn.onclick = function() {
  /*170*/   // If we used the 6th row
  /*171*/   if (isUsingManualChoice && manualChosenClient) {
  /*172*/     selectedClient = manualChosenClient;
  /*173*/   }
  /*174*/   // Then run the original logic
  /*175*/   oldApplyClick();
  /*176*/ };

  /*177*/ matchesDiv.appendChild(applyBtn);

  /*178*/ // Now that applyBtn is defined, we can finalize adding li6 to the UL
  /*179*/ clientList.appendChild(li6);

  // DONE
}


/**
 * Actually loads the chosen client in the UI, puts the leftover text (task minus name) into
 * either #newPastWork or #newFollowUp, then calls the server to delete the row from tasks.
 */
function doApplyTaskToClient(chosenClient, chosenWorkType, taskObj, rowId) {
  // 1) Hide any existing client notes
  hideClientNotes();

  // 2) Set the #clientSelect to the chosen client (if it exists)
  var clientSelect = document.getElementById('clientSelect');
  if (clientSelect) {
    // Try to find an exact match
    for (var i = 0; i < clientSelect.options.length; i++) {
      if (clientSelect.options[i].value === chosenClient) {
        clientSelect.selectedIndex = i;
        break;
      }
    }
  }
  // Also set the clientAutocomplete field
  var clientAutocomplete = document.getElementById('clientAutocomplete');
  if (clientAutocomplete) {
    clientAutocomplete.value = chosenClient;
  }

  // 3) Show that client's notes
  showClientNotes();
  window.scrollTo({ top: 0, behavior: 'smooth' });


  // 4) Insert the leftover text into Past or Future
  //    "Leftover text" is everything AFTER the extracted name portion
  var leftover = stripNameFromTask(taskObj.fullTask, chosenClient);
  if (chosenWorkType === 'PAST') {
    document.getElementById('newPastWork').value = leftover;
  } else {
    document.getElementById('newFollowUp').value = leftover;
  }

  // 5) Delete the row from the tasks spreadsheet
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // Remove that task row from the DOM
      var rowDiv = document.getElementById(rowId);
      if (rowDiv) rowDiv.remove();
      alert("Task successfully applied and removed from Tasks.");
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert("Error removing task from spreadsheet: " + err.message);
    })
    .deleteTaskRow(taskObj.rowIdInTasks); // We'll define deleteTaskRow() in Code.gs
}

/**
 * Strips the leading name portion from the full task text. This is rough logic – modify as needed.
 */
function stripNameFromTask(fullTask, chosenClientName) {
  // Simplify by removing the first words that match chosenClientName, or at least the first 2-3 words
  // For best results, do a simple approach:
  var re = new RegExp(chosenClientName, 'i');
  var leftover = fullTask.replace(re, '').trim();
  return leftover;
}

/*********************************
 * SNIPPET: findClientName
 * Paste this directly after the
 * stripNameFromTask function’s
 * closing brace
 *********************************/
function findClientName(fullTask, clientNamesArray) {
  // This loops through each client name in the array
  for (var i = 0; i < clientNamesArray.length; i++) {
    var name = clientNamesArray[i];
    // Create a case-insensitive RegExp for that name
    var re = new RegExp(name, 'i');
    // If the name is found anywhere in fullTask...
    if (re.test(fullTask)) {
      // ...immediately return it.
      return name;
    }
  }
  // If no name is found, return null
  return null;
}

function scrollToBottomInOneSecond() {
  // Current scroll position
  const startY = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;

  // Target scroll position (bottom of the page)
  const doc = document.documentElement;
  const body = document.body;
  const fullHeight = Math.max(
    body.scrollHeight, body.offsetHeight, body.clientHeight,
    doc.scrollHeight,  doc.offsetHeight,  doc.clientHeight
  );
  const targetY = Math.max(0, fullHeight - window.innerHeight);

  // If we're basically there, do nothing
  if (Math.abs(targetY - startY) < 2) return;

  const duration = 1000; // 1 second
  let startTime = null;

  // Ease-in-out (quadratic) for a pleasant feel
  function easeInOutQuad(t) {
    return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
  }

  function step(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = timestamp - startTime;
    const t = Math.min(1, elapsed / duration);
    const eased = easeInOutQuad(t);
    const y = startY + (targetY - startY) * eased;
    window.scrollTo(0, y);

    if (t < 1) {
      requestAnimationFrame(step);
    }
  }

  requestAnimationFrame(step);
}

// Build chip element for the highlighted FOLLOW UP line.
// If initials/date are blank, show placeholder " | " with neutral color.

function createChipElement(clientName, initials, mmddyy) {
  var safeInitials = (initials || "").toUpperCase().trim();

  // ✅ Normalize the date to always display as M/D/YY
  var safeDate = normalizeChipDate(mmddyy || "");

  var chip = document.createElement('span');
  chip.className = 'chip ' + (safeInitials ? safeInitials : 'EMPTY');

  // If both initials and date are empty, show a neutral placeholder
  if (!safeInitials && !safeDate) {
    var ph = document.createElement('span');
    ph.className = 'chip-assign';
    ph.textContent = '(ASSIGN)';
    chip.appendChild(ph);
  } else {
    // Render "INITIALS | M/D/YY"
    var initEl = document.createElement('span');
    initEl.className = 'chip-initials';
    initEl.textContent = safeInitials;

    var sepEl = document.createElement('span');
    sepEl.className = 'chip-sep';
    sepEl.textContent = ' • ';

    var dateEl = document.createElement('span');
    dateEl.className = 'chip-date';
    dateEl.textContent = safeDate;

    chip.appendChild(initEl);
    chip.appendChild(sepEl);   // <-- you were missing this line
    chip.appendChild(dateEl);
  }

  // Clicking the chip still opens the inline editor
  chip.addEventListener('click', function(ev) {
    ev.stopPropagation();
    openChipEditor(chip, clientName, safeInitials, safeDate);
  });

  return chip;
}

// READ-ONLY chip for the Top Clients list (no click-to-edit)
function createChipElementReadOnly(clientName, initials, mmddyy) {
  var safeInitials = (initials || "").toUpperCase().trim();

  // Reuse your normalizer
  var safeDate = normalizeChipDate(mmddyy || "");

  var chip = document.createElement('span');
  chip.className = 'chip ' + (safeInitials ? safeInitials : 'EMPTY');

  if (!safeInitials && !safeDate) {
    var ph = document.createElement('span');
    ph.className = 'chip-assign';
    ph.textContent = '(ASSIGN)';
    chip.appendChild(ph);
  } else {
    var initEl = document.createElement('span');
    initEl.className = 'chip-initials';
    initEl.textContent = safeInitials;

    var sepEl = document.createElement('span');
    sepEl.className = 'chip-sep';
    sepEl.textContent = ' | ';

    var dateEl = document.createElement('span');
    dateEl.className = 'chip-date';
    dateEl.textContent = safeDate;

    chip.appendChild(initEl);
    chip.appendChild(sepEl);
    chip.appendChild(dateEl);
  }

  // IMPORTANT: no click handler attached — read-only.
  return chip;
}




// === REPLACEMENT: Auto-save chip editor (no Save/Cancel buttons) ===
function openChipEditor(anchorEl, clientName, initials, mmddyy) {
  closeAnyChipEditor(); // ensure only one editor open

  var editor = document.createElement('div');
  editor.id = 'chipEditorPopover';
  editor.style.position = 'absolute';
  editor.style.zIndex = '99999';
  editor.style.background = '#fff';
  editor.style.border = '1px solid #ccc';
  editor.style.borderRadius = '8px';
  editor.style.padding = '8px';
  editor.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
  editor.style.fontSize = '14px';
  editor.style.display = 'flex';
  editor.style.alignItems = 'center';
  editor.style.gap = '8px';

  // initials dropdown
  var sel = document.createElement('select');
  ['','RB','JB','TEAM','QC'].forEach(function(opt){
    var o = document.createElement('option');
    o.value = opt; o.textContent = opt || '(none)';
    if (opt === (initials || '')) o.selected = true;
    sel.appendChild(o);
  });

  // date input (native)
  var dateInput = document.createElement('input');
  dateInput.type = 'date';

  // prefill date from MM/DD/YY → YYYY-MM-DD
  if (mmddyy) {
    var m = mmddyy.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      var y = parseInt(m[3],10); if (y < 100) y = 2000 + y;
      var iso = y + '-' + String(parseInt(m[1],10)).padStart(2,'0') + '-' + String(parseInt(m[2],10)).padStart(2,'0');
      dateInput.value = iso;
    }
  }

  editor.appendChild(sel);
  editor.appendChild(dateInput);
  document.body.appendChild(editor);

  // position next to chip
  var rect = anchorEl.getBoundingClientRect();
  editor.style.top = (window.scrollY + rect.bottom + 6) + 'px';
  editor.style.left = (window.scrollX + rect.left) + 'px';

  // helper: run save with current select + date values
  function saveChipAndClose() {
    var newInitials = sel.value;
    var newIso = dateInput.value || ''; // '' allowed

    // Show loading, save, update chip, close editor
    showLoadingBar();
    google.script.run.withSuccessHandler(function(){
      hideLoadingBar();

      // Convert ISO → MM/DD/YY for chip display
      var newMmddyy = '';
      if (newIso) {
        var d = new Date(newIso);
        newMmddyy = (d.getMonth()+1).toString().padStart(2,'0') + '/' +
                    d.getDate().toString().padStart(2,'0') + '/' +
                    (d.getFullYear()%100).toString().padStart(2,'0');
      }

      renderChipInto(anchorEl, clientName, newInitials, newMmddyy);
      closeAnyChipEditor();
      // ---- NEW: ensure BOTH chip instances refresh ----
try {
  // Refresh the Top Clients list (updates chips inside More/Less cards)
  if (typeof displayTopClients === 'function') {
    displayTopClients();
  }

  // If the currently loaded notes belong to this client, refresh them too
  var sel = document.getElementById('clientSelect');
  if (sel && sel.value && sel.value.trim() === clientName.trim()) {
    if (typeof showClientNotes === 'function') {
      showClientNotes();
    }
  }
} catch (e) {
  console.warn('Post-save refresh warning:', e);
}

    }).withFailureHandler(function(err){
      hideLoadingBar();
      alert('Failed to update chip: ' + err.message);
    }).updateClientChip(clientName, newInitials, newIso || null);
  }

  // AUTO-SAVE behaviors:
  // 1) Change initials → save immediately
  sel.addEventListener('change', saveChipAndClose);
  // 2) Pick a date → save immediately
  dateInput.addEventListener('change', saveChipAndClose);
  // 3) Click outside the popover → close without saving (no change made)
  setTimeout(function() { // defer to avoid immediate close on open
    document.addEventListener('mousedown', outsideHandler);
  }, 0);

  function outsideHandler(e) {
    var ed = document.getElementById('chipEditorPopover');
    if (ed && !ed.contains(e.target)) {
      closeAnyChipEditor();
      document.removeEventListener('mousedown', outsideHandler);
    }
  }
}


function closeAnyChipEditor() {
  var existing = document.getElementById('chipEditorPopover');
  if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
}

// Swap the existing chip node with a re-rendered one (keeps position).
function renderChipInto(oldChipEl, clientName, initials, mmddyy) {
  var parent = oldChipEl.parentNode;
  if (!parent) return;
  var newChip = createChipElement(clientName, initials, mmddyy);
  parent.replaceChild(newChip, oldChipEl);
}
// === HELPER: convert chip date to sortable timestamp ===
// Blank or invalid dates will return NEGATIVE_INFINITY so they sort to the TOP.
function chipDateToTime(raw) {
  if (!raw) return Number.NEGATIVE_INFINITY; // blanks go to top
  var s = normalizeChipDate(raw);
  if (!s) return Number.NEGATIVE_INFINITY;

  // Match MM/DD/YY or MM/DD/YYYY
  var m1 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2}|\d{4})$/);
  if (m1) {
    var mm = parseInt(m1[1],10), dd = parseInt(m1[2],10), yy = parseInt(m1[3],10);
    if (yy < 100) yy += 2000;
    var d1 = new Date(yy, mm-1, dd);
    return isNaN(d1.getTime()) ? Number.NEGATIVE_INFINITY : d1.getTime();
  }

  // Match YYYY-MM-DD
  var m2 = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (m2) {
    var y = parseInt(m2[1],10), m = parseInt(m2[2],10), d = parseInt(m2[3],10);
    var d2 = new Date(y, m-1, d);
    return isNaN(d2.getTime()) ? Number.NEGATIVE_INFINITY : d2.getTime();
  }

  // Fallback
  var d3 = new Date(s);
  return isNaN(d3.getTime()) ? Number.NEGATIVE_INFINITY : d3.getTime();
}

function onToplistSuggestionBlur(clientName, newValue) {
  if (!clientName) return;
  showLoadingBar();
  google.script.run
    .withSuccessHandler(function() {
      hideLoadingBar();
      // FULL refresh so ShowClientNotes + Top Clients match exactly
      location.reload();
    })
    .withFailureHandler(function(err) {
      hideLoadingBar();
      alert('Error saving Ricky\'s Suggestion: ' + (err && err.message ? err.message : err));
    })
    .updateInProgress(clientName, newValue); // Apps Script: writes Column L for that client
}


function ensureSuggestionsButtonInToolbar() {
  // Find a host element in the existing toolbar (try both IDs you already use)
  var host = document.getElementById('topClientsFilter') || 
             document.getElementById('userSelection');

  if (!host) return; // nothing to do if toolbar isn't mounted yet

  // Avoid duplicates
  if (document.getElementById('suggestionsToggleBtn')) return;

  // Style the toolbar row if not already styled
  var toolbarRow = host.parentElement;
  if (toolbarRow && !toolbarRow.classList.contains('top-controls')) {
    toolbarRow.classList.add('top-controls');
  }

  // Create the inline SUGGESTIONS toggle button
  var btn = document.createElement('button');
  btn.id = 'suggestionsToggleBtn';
  btn.type = 'button';
  btn.textContent = '💡';
  btn.onclick = function () {
    if (typeof toggleSuggestions === 'function') toggleSuggestions();
  };

  // Insert immediately after the filter control
  host.insertAdjacentElement('afterend', btn);
}

// Run once after page builds (safe to call multiple times)
document.addEventListener('DOMContentLoaded', ensureSuggestionsButtonInToolbar);
// Also run after you redraw/refresh top clients, just in case:
(function patchAfterDraw(){
  var _old = window.showTopClients;
  if (typeof _old === 'function') {
    window.showTopClients = function() {
      var r = _old.apply(this, arguments);
      try { ensureSuggestionsButtonInToolbar(); } catch(e){}
      return r;
    };
  }
})();

// Wire #categorySelect change to handle normal updates vs. NEW CATEGORY modal
(function wireCategorySelectChange(){
  var sel = document.getElementById('categorySelect');
  if (!sel || sel._wiredForNewCat) return;
  sel.addEventListener('change', function() {
    var v = sel.value;

    if (v === '__NEW__') {
      // Open modal and revert select to prior value to avoid accidental save
      sel.value = '';
      openNewCategoryModal();
      return;
    }

    // Normal path: save the chosen category for the current client
    if (v) {
      updateCategory();       // already defined in your file
      updateCategoryLabel();  // already defined in your file
    }
  });
  sel._wiredForNewCat = true;
})();



  // Example renderer (adapt to your UI)
  function renderRecentBar(items) {
    // items: [{name, tsISO, category, columnL, chipInitials, chipDate}, ...]
    // Build your pill bar here. For example:
    // - show name
    // - show category as a small badge
    // - show chipInitials + chipDate as a tiny chip
    // - maybe a small dot if columnL (in-progress) is non-empty
  }

  // On initial load
  document.addEventListener('DOMContentLoaded', refreshRecentBar);



  // Build the pills
  function renderRecentBar(items) {
    const bar = document.getElementById('recentClientsBar');
    if (!bar) return;

    if (!items || !items.length) {
      bar.innerHTML = `<span style="opacity:.7">No recent clients yet.</span>`;
      return;
    }

    bar.innerHTML = items.map(it => {
      const hasInProgress = it.columnL && it.columnL.trim().length > 0;
      const dot = `<span class="rc-dot ${hasInProgress ? '' : 'rc-muted'}" title="${hasInProgress ? 'In Progress' : 'No In Progress'}"></span>`;
      const cat = it.category ? `<span class="rc-cat" title="Category">${it.category}</span>` : '';
      const chip = (it.chipInitials || it.chipDate)
          ? `<span class="rc-chip" title="Owner/Date">${(it.chipInitials||'').trim()} ${(it.chipDate||'').trim()}</span>` : '';
      return `
        <button class="recent-pill" onclick="selectClientFromRecent('${escapeHtml(it.name)}')">
          ${dot}
          <span class="rc-name">${escapeHtml(it.name)}</span>
          ${cat}
          ${chip}
        </button>
      `;
    }).join('');
  }

  // When a pill is clicked, do whatever your app already does to open a client:
  function selectClientFromRecent(name) {
    // Example: set your dropdown + trigger your existing load
    const dd = document.getElementById('clientDropdown');
    if (dd) {
      dd.value = name;
      // call your existing loader function if you have one
      if (typeof onClientSelected === 'function') onClientSelected();
      // also re-log to bump it to top (optional)
      onClientOpened(name);
    }
  }

  // Simple HTML escaper for safety
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // Load the bar on page load
  document.addEventListener('DOMContentLoaded', refreshRecentBar);

 // 1) Call this whenever a client is opened/loaded in your UI
  function onClientOpened(clientName) {
    if (!clientName) return;
    google.script.run
      .withSuccessHandler(refreshRecentBar)
      .logRecentClient(clientName, 4);
  }

  // 2) Ask server for the list, then render
  function refreshRecentBar() {
    google.script.run
      .withSuccessHandler(renderRecentBar)
      .getRecentClients(4, /* refreshMetadata */ true);
  }

  // 3) Paint the pills into #recentClientsBar
  function renderRecentBar(items) {
    const bar = document.getElementById('recentClientsBar');
    if (!bar) return;

    if (!items || !items.length) {
      bar.innerHTML = `<span style="opacity:.4">No recent clients yet.</span>`;
      return;
    }

    bar.innerHTML = items.map(it => {
      const hasInProgress = it.columnL && it.columnL.trim().length > 0;
      const dot  = `<span class="rc-dot ${hasInProgress ? '' : 'rc-muted'}" title="${hasInProgress ? 'In Progress' : 'No In Progress'}"></span>`;
      const cat  = it.category ? `<span class="rc-cat" title="Category">${escapeHTML(it.category)}</span>` : '';
      const chip = (it.chipInitials || it.chipDate)
        ? `<span class="rc-chip" title="Owner/Date">${escapeHTML(it.chipInitials || '')} ${escapeHTML(it.chipDate || '')}</span>`
        : '';
      return `
        <button class="recent-pill" onclick="selectClientFromRecent('${escapeHTML(it.name)}')">
          ${dot}
          <span class="rc-name">${escapeHTML(it.name)}</span>
          ${cat}
          ${chip}
        </button>
      `;
    }).join('');
  }

  // 4) What happens when a pill is clicked
  function selectClientFromRecent(name) {
    // Put the name into your dropdown + trigger your existing loader
    const dd = document.getElementById('clientSelect');
    if (dd) {
      dd.value = name;
      // Mirror the text in your autocomplete input
      const txt = [...dd.options].find(o => o.value === name)?.text || name;
      const auto = document.getElementById('clientAutocomplete');
      if (auto) auto.value = txt;

      if (typeof showClientNotes === 'function') showClientNotes(); // your existing flow
      onClientOpened(name); // bump to top
      // Optional: scroll to top where your notes live
      if (typeof scrollToTop === 'function') scrollToTop();
    }
  }

// Re-run the Top Clients filter as if the dropdown changed (even if value didn’t)
function retriggerTopClientsFilter() {
  var dd = document.getElementById('topClientsFilterDropdown');
  if (!dd) return;
  try {
    dd.dispatchEvent(new Event('change', { bubbles: true }));
  } catch (_) {
    // Fallback if the listener ignores synthetic events
    if (typeof syncClientsListToDropdown === 'function') {
      syncClientsListToDropdown();
    } else if (typeof handleTopClientsFilterChange === 'function') {
      handleTopClientsFilterChange(dd.value || 'JB');
    }
  }
}


  // 5) Load the bar on first paint
  document.addEventListener('DOMContentLoaded', refreshRecentBar);



</script>




</body>
</html>
